<p data-pid="WybiDtEX">当前，前端社区用 Vite 替代 Webpack 的呼声正日趋高涨。但对于长期维护的业务项目，很多同学可能仍然对上车存有疑虑——Vite 真的足够支撑非玩具级的项目吗？为此本文会分享一个实际案例，介绍我们是如何（比较轻松地）在公司核心业务中落地 Vite 的。</p><p data-pid="ph9ny_Pk">稿定 Web 端业务中的平面编辑器已经有五年以上的历史。作为一个历经多人主导维护的前端项目，它有这么一些复杂度：</p><ul><li data-pid="YSRN-DTH">编辑器使用基于 Yarn workspace 和 Lerna 的宏仓库来管理源码，其中有近 20 个 package，初始化时会加载超过 400 个模块，并有 2GB 以上的 node_modules 依赖。</li><li data-pid="tmavD-BB">编辑器模块最早使用 Vue 0.8 和 AMD 模块语法 ，历经 Vue 1.x 和 2.x 时代维护至今。Webpack 也是从无到有，再从 1.x 一路升级到了现在的 4.x 版本。</li><li data-pid="9WeePjXl">编辑器内的部分高级渲染功能，用到了 Worker 和 WASM 的能力。</li><li data-pid="7kjrMjEQ">编辑器整体作为单个 NPM 包发布到公司私有仓库上供业务接入，有独立的打包和发版流程。</li></ul><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-295ed6e42b0c98de70c1b9f86c284583_b.jpg" data-size="normal" data-rawwidth="1950" data-rawheight="842" class="origin_image zh-lightbox-thumb" width="1950" data-original="https://pic4.zhimg.com/v2-295ed6e42b0c98de70c1b9f86c284583_r.jpg" data-original-token="v2-295ed6e42b0c98de70c1b9f86c284583"/><figcaption>编辑器在 2016 年的第一次提交，基于 Vue 0.8 和 AMD 语法</figcaption></figure><p data-pid="glyE7yz3"> 我们不敢说这就是所谓的「大型企业级」项目，但这至少肯定不是个玩具项目。然而超乎预期的是，<b>Vite 的迁移成本甚至比升级 Webpack 和 Babel 大版本还要低</b>。只花了一个下午的时间，基于 Vite 的编辑器最小可用 MVP 就跑起来了。下面分几点介绍相关的实践经验：</p><ul><li data-pid="ks0CTGPt">如何规划基本的迁移思路，以及一些基础的知识储备。</li><li data-pid="oDHKjEun">如何通过编写插件来解决一些 Webpack loader 的问题。</li><li data-pid="4MnnPthK">如何迁移常见的 Webpack 配置。</li><li data-pid="RtkGGKH_">如何处理上游依赖问题。</li></ul><h2>知识背景与思路</h2><p data-pid="k1MYLTR4">我们知道，以 Webpack 为代表的主流前端 bundler 之所以慢，根源在于它们冷启动时必须递归打包出整个项目的依赖树，并受限于 JavaScript 的天性（解释执行与单线程模型）而存在吞吐量上的瓶颈。为了解决这两个痛点，Vite 另起炉灶切换了路线：</p><ul><li data-pid="Psd0nmzE">对于项目中的业务模块，Vite 利用现代浏览器内置的 ES Module 支持，由浏览器直接向 dev server 逐个请求加载这些模块——因此你往往可以看到本地环境下大量的 HTTP 请求刷屏，这也是 Vite 最鲜明的特征。</li><li data-pid="pqY7tQh7">对于项目中的 node_modules 依赖，Vite 借助 <a href="https://link.zhihu.com/?target=https%3A//esbuild.github.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">esbuild</a> 这类由原生语言开发的高性能 bundler，将这些库中非 ESM 标准（CommonJS 或 UMD）的模块整体打包为 ESM，即所谓的 <a href="https://link.zhihu.com/?target=https%3A//vitejs.dev/guide/dep-pre-bundling.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Dependency Pre-Bundling</a>。这个过程的打包结果具备缓存，并且冷启动重建缓存的效率也极高。</li></ul><p data-pid="1eldw3CM">Vite 的这个设计与 <a href="https://link.zhihu.com/?target=https%3A//webpack.js.org/configuration/dev-server/" class=" wrap external" target="_blank" rel="nofollow noreferrer">webpack-dev-server</a> 之间的区别，在其文档中也已经展示得很清楚，一图胜千言：</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-9affcc8711ebfcd3d3cc7269c57ced52_b.jpg" data-size="normal" data-rawwidth="1918" data-rawheight="1068" class="origin_image zh-lightbox-thumb" width="1918" data-original="https://pic3.zhimg.com/v2-9affcc8711ebfcd3d3cc7269c57ced52_r.jpg" data-original-token="v2-9affcc8711ebfcd3d3cc7269c57ced52"/><figcaption> Webpack 式的经典 bundler 示意图</figcaption></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-916a6df6ac5972e0594a1be4c5fff31c_b.jpg" data-size="normal" data-rawwidth="1646" data-rawheight="1030" class="origin_image zh-lightbox-thumb" width="1646" data-original="https://pic1.zhimg.com/v2-916a6df6ac5972e0594a1be4c5fff31c_r.jpg" data-original-token="v2-916a6df6ac5972e0594a1be4c5fff31c"/><figcaption>Vite 式的 No-bundler 示意图</figcaption></figure><p data-pid="QLpc23M_">基于这个差异我们就可以知道，要让 Vite 支持原有的 Webpack 项目，需要保证的无非两件事：</p><ul><li data-pid="S0Kxs20W">确保业务模块源码均符合 ESM 规范。</li><li data-pid="Y9PIqyFx">确保依赖均可正确被 esbuild 处理。</li></ul><p data-pid="6rPKYGz_">当然这只是最简单的思维模型。实际的前端项目中往往还会引入一些奇怪的东西，比如 CSS、JSON、Worker、WASM、HTML 模板……虽然 Vite 对这些需求已经内建了良好的支持，但确实谁也不敢保证能一键开箱即用——这并不是 Vite 或 Webpack 的问题，而是移植代码构建环境时的共通难点。对这类任务，<b>最难的地方总在于从零到一的「点亮」</b>。因此这里对此的建议是这样的：<b>充分熟悉从项目入口到各组件渲染完成之间所经历的代码（子）树，确保这一个最小的子集能够在新环境下正常运作</b>。其他代码都可以大刀阔斧地暂时移除掉。</p><p data-pid="kBSRysHn">对于架构设计合理的软件项目，一般都可以容易地实现模块的精简和扩展。例如在这个编辑器中，我们就支持了可配置并按需加载的元素类型。对于现有的 20 余种业务元素，它们对应的模块都已经支持了按需加载，只会在遇到相应数据时 <code>import()</code> 导入。因此在迁移时，只需保留若干基础元素模块实现用于测试即可。类似地，在业务项目中也可以通过精简路由配置等方式，定制出一个用于走通主流程的最小可用版本。</p><h2>自定义插件实现</h2><p data-pid="XXiJCnr2">上述的代码精简过程，其实不外乎是建立一个干净的 example 页面来导入项目，注释掉部分代码然后反复执行 <code>vite</code> 命令测试，这里不再赘述。对于 Vite 迁移，很多同学最担忧的可能还是 Webpack 插件兼容性方面的问题。我们恰好也遇到了类似的问题，这里简单分享一下。</p><p data-pid="xQ0ts8vS">在前面 2016 年的编辑器上古版本代码截图中有一个细节，那就是其中引入了 <code>editor.html</code> 作为组件的 HTML 模板。这个行为历经多年一直保留到了现在——也就是说这里没有使用 SFC 单文件组件，而是对 <code>text-element.js</code> 等组件配套放一个 <code>text-element.html</code> 作为其模板，像这样：</p><div class="highlight"><pre><code class="language-js"><span class="c1">// 导入 HTML 源码
</span><span class="c1"></span><span class="kr">import</span> <span class="nx">TextElementTpl</span> <span class="nx">from</span> <span class="s1">&#39;./text-element.html&#39;</span>

<span class="c1">// Vue 2.0 的经典配置
</span><span class="c1"></span><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">template</span><span class="o">:</span> <span class="nx">TextElementTpl</span><span class="p">,</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">},</span>
  <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p data-pid="W6BOHnQF">在 Webpack 配置中，我们一般会用 HTML loader 来支持它，那么 Vite 呢？这类需求似乎并没有内置，而现在社区的 <a href="https://link.zhihu.com/?target=https%3A//github.com/anncwb/vite-plugin-html" class=" wrap external" target="_blank" rel="nofollow noreferrer">vite-plugin-html</a> 是为 EJS 模板设计的，star 数量好像也不多……但真的就要等社区做现成的给你吗？</p><p data-pid="gGm-OtXB">其实，Vite 的插件系统是直接依赖 rollup 的。对于这个需求，只要这样在 <code>vite.config.js</code> 里写个几行的插件就够了：</p><div class="highlight"><pre><code class="language-js"><span class="c1">// 使用 rollup 附带的 plugin utils
</span><span class="c1"></span><span class="kr">const</span> <span class="p">{</span> <span class="nx">createFilter</span><span class="p">,</span> <span class="nx">dataToEsm</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;@rollup/pluginutils&#39;</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">createMyHTMLPlugin</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 建立一个用于筛选模块的 filter
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="nx">createFilter</span><span class="p">([</span><span class="s1">&#39;**/*.html&#39;</span><span class="p">]);</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;vite-plugin-my-html&#39;</span><span class="p">,</span> <span class="c1">// 起个名字
</span><span class="c1"></span>    <span class="c1">// 根据 id 来筛选模块，并在遇到匹配的模块时变换其 source
</span><span class="c1"></span>    <span class="nx">transform</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">filter</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
      <span class="c1">// 这样 HTML 字符串就能被 export default 给其他 JS 模块了
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">dataToEsm</span><span class="p">(</span><span class="nx">source</span><span class="p">);</span>
    <span class="p">},</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 这样就可以按照 Vite 的标准 API 来使用插件了
</span><span class="c1"></span><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span><span class="nx">createMyHTMLPlugin</span><span class="p">()],</span>
<span class="p">}</span>
</code></pre></div><p data-pid="av1Zcm5M">这个 <code>createMyHTMLPlugin</code> 不就是个非常简单的函数而已吗？但它却切实地解决了一个实际问题。个人认为对用户友好的构建系统应该做到在大多数时候能开箱即用，并能通过简单的逻辑自行扩展。在这一点上，可以说 Vite 还是做得相当出色的。另外 Vite 相比 Snowpack 的一个主要区别，就是它的插件系统与 Rollup 有更深的集成，由此实现了在 dev 和 build 两种模式下通用的插件 API。因此在业务中，也有机会自行「套壳」一些成熟的 Rollup 插件来实现需求。</p><h2>常见 Webpack 配置迁移</h2><p data-pid="EcTOyVhJ">在这次实践中用到的 Vite 配置相当少，值得一提的主要是这么几条：</p><ul><li data-pid="Uhzk0KPb">通过 <code>resolve.alias</code> 配置，可以覆写（或者说劫持）掉模块路径。注意最好尽量让这个配置少一点，滥用它容易降低代码模块结构对工具链的友好性。</li><li data-pid="GDdGcxtv">通过 <code>define</code> 配置，可以支持 <code>process.env.__DEV__</code> 这样的环境变量注入。注意 Vite 会把字符串直接注入成产物代码中的 raw expression，所以如果只想传递 <code>true</code> 这种简单常量，要额外 <code>JSON.stringify</code> 包一层。</li><li data-pid="C8T_JEO-">通过 <code>vite-plugin-vue2</code> 可以支持 Vue 2.0 的 SFC。这里的理由在于虽然编辑器内的主要组件没有使用 SFC，但测试页面的 demo 入口是个 <code>app.vue</code>。通过这个插件，可以让它们良好地共存。</li><li data-pid="LYBopq_U">Less 和 CSS 依赖了 Vite 的内置支持，没有引入额外的配置。当然另一种变通方案是先执行独立打包 CSS 的命令，然后 <code>import &#34;./dist.css&#34;</code> 即可。</li><li data-pid="GoQJwvu_">通过 <code>import Worker from &#34;worker.js?worker&#34;</code> 的语法，可以支持 Web Worker。另外也可以进一步将其配合 <code>resolve.alias</code> 配置，来继续兼容 Webpack。</li><li data-pid="HPnXDuru">对于 WASM，除了形如 <code>import init from &#34;./a.wasm&#34;</code> 的内置支持以外，还有一种实践是让 WASM 的 JS 适配层支持传入可配置的 WASM 路径，这方面比较典型的例子可以参考 <a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/canvaskit-wasm" class=" wrap external" target="_blank" rel="nofollow noreferrer">CanvasKit</a> 等包。</li></ul><h2>上游依赖问题处理</h2><p data-pid="-vFhixRD">基于上面介绍的这些实践，应当已经足够解决 Vite 对各类业务模块的加载问题了。但最后还有一个比较头疼的地方：如果 node_modules 中的依赖不能被 esbuild 正确打包，又该怎么办呢？</p><p data-pid="Z-CncI_C">在这次迁移中，这样的问题我们有遇到两处，各自的原因有所不同：</p><ul><li data-pid="Jcli_QiI">图片重采样库 <a href="https://link.zhihu.com/?target=https%3A//github.com/nodeca/pica" class=" wrap external" target="_blank" rel="nofollow noreferrer">Pica</a> 依赖了一个简易的 Web Worker 转换库，它会直接在模块代码顶层读取 <code>arguments</code> 数据，导致 esbuild 报错。</li><li data-pid="hKkuG-hU">字体解析库 <a href="https://link.zhihu.com/?target=https%3A//github.com/opentypejs/opentype.js" class=" wrap external" target="_blank" rel="nofollow noreferrer">OpenType.js</a> 为了同时兼容浏览器端和 Node，在 ESM 源码中封装了若干 <code>require(&#39;fs&#39;)</code> 的函数。这也会导致报错。</li></ul><p data-pid="BidlSXoH">对于这两个问题，其实都有一种通用的 workaround 手法：<b>建立一个 third_party 目录，把存在问题的上游模块拷贝一份进去，在这里修复问题并调整模块依赖即可</b>。如 Pica 库内 <code>require(&#39;./a.js&#39;)</code> 的代码，就可以复制到 third_party 目录后，将模块导入路径改为 <code>require(&#39;pica/src/a.js&#39;)</code>，这样并不需全量复制整个上游依赖。而对于这里遇到的两个 CommonJS 问题，具体的修复也都很容易，例如把对 <code>arguments</code> 的读取放到 <code>export default</code> 的函数体内，并直接移除在浏览器环境下用不到的 Node 文件读取逻辑等。这样的 third_party 模式实际上倒也不算什么 hack，在很多语言的工程中有很广泛的使用，但也有些地方值得注意：</p><ul><li data-pid="KefnfGQE">建议在改动位置添加 <code>// FIXME</code> 之类的注释，方便接受者确认修改之处。</li><li data-pid="lUM8coUv">如果需要集成很大的上游依赖，那么不建议直接放到代码库里，可以使用 git submodule 或 CDN 等形式。</li><li data-pid="KbRZEKMA">理想情况下应当向上游反馈 patch，解决问题后移除相应的本地版本。</li></ul><p data-pid="6lGwoJ8K">以上就是全部值得列出的问题了，最后放一张基于 Vite 启动本地环境成功时的截图：</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-0053746dba75856cc01f04062a2f3079_b.jpg" data-caption="" data-size="normal" data-rawwidth="1611" data-rawheight="928" class="origin_image zh-lightbox-thumb" width="1611" data-original="https://pic2.zhimg.com/v2-0053746dba75856cc01f04062a2f3079_r.jpg" data-original-token="v2-0053746dba75856cc01f04062a2f3079"/></figure><p data-pid="Do6IB8r8">上图的日志有个问题，即加载了两个不同的 Vue 版本。这是因为 SFC 部分和依赖 HTML 模板的代码误用了不同的 Vue 依赖。这个问题后来通过 <code>alias</code> 配置将 <code>vue</code> 全部重写到 <code>vue/dist/vue</code> 而解决了。</p><p data-pid="Uhf0mCdk">由于编辑器 SDK 原本就使用 Babel 独立发版，因此原有的 NPM 发布过程不受影响，Vite 整体的侵入性也并不高。至于最终效果上也没有什么别的，就是油门踩到底加速了一下：</p><ul><li data-pid="l9wgulSJ">Webpack 40 秒以上的 dev server 冷启动时间缩短到了 1.5 秒内，在建立 <code>.vite</code> 目录缓存后，启动 <code>vite</code> 命令的时间仅需约 300 毫秒。</li><li data-pid="wQO0YwY-">修改单个文件后 2 秒左右的增量编译时间被完全优化掉了，同时浏览器中加载页面的效率并没有明显差异。</li></ul><p data-pid="nIfTokUL">这样一来，这个历史项目就重新获得了即时反馈级别的开发体验，同时也让更高效的 CI 集成成为了可能。这里的想象空间还很大，我们很期待让 Vite 在未来发挥出更大的作用。</p><h2>总结</h2><ul><li data-pid="1eLF4Vay">Vite 做到了以低接入代价换取开发体验上的大幅提升，有望引领前端构建工具领域的下一波 <i>paradigm shift</i> 浪潮。按 ROI 的话说，<b>其落地的潜在收益远大于成本</b>。</li><li data-pid="wFmtfHV0">实际业务中的代码应当尽量贴合标准，少使用需依赖工具链黑魔法的特性，以换取更好的后向兼容性。</li><li data-pid="X4Y90jL1">对于代码移植，实践中其实还有很多（未必上得了台面的）奇技淫巧，比如正则替换、编写 codemod 和为下游业务提供 deprecated API 检测脚本等等——扪心自问，把抄来代码里的 <code>var</code> 全部查找替换成 <code>let</code> 这种事你干过没有？这些手段并没有什么高下之分，能简单方便地解决问题就好。</li><li data-pid="3VjzKC-7">JavaScript 本身哪怕作为编译后的产物，仍然是易读、易修改，且易向上游 backport 反馈的。主流的编译型语言都不容易做到这一点——类似于你把 DLL 里函数符号的机器码或 Java class 文件里的字节码改完，马上就能照着 diff 直接去给上游库提 PR。这是黑魔法的源头，可能也是种前端的「道路自信」吧。</li></ul><p data-pid="Xtw0EwX2">实际上作为本文的作者，之前个人还尝试过一些类似的代码移植。这类工作就像是一个破解密室逃脱游戏的过程，非常有趣。个人感觉像这次的 Vite 迁移，在实践手段上其实和之前的经历都是相当共通的：</p><ul><li data-pid="wUply2LN"><a href="https://zhuanlan.zhihu.com/p/330586852" class="internal">将 1995 年世界上最早的 JS 引擎源码编译回 JavaScript</a></li><li data-pid="IVqBMLz7"><a href="https://zhuanlan.zhihu.com/p/296388598" class="internal">将 Dart VM 从 Flutter 中抽离出来，单独在 iOS 原生项目中使用</a></li><li data-pid="TwMxo9r3"><a href="https://zhuanlan.zhihu.com/p/97851599" class="internal">为国产掌机搭建嵌入式 Linux 工具链，把 QuickJS 引擎移植上去</a></li></ul><p data-pid="d5x_LmLf">所以最后，非常鼓励大家多做兴趣驱动的技术尝试。没准未来的哪天，折腾它们的经验就能帮助你找到抓手，赋能业务，形成闭环，打出一套组合拳呢（</p><blockquote data-pid="l3tI4szg">我们在正在杭州、深圳、厦门等 base 招人，欢迎私信或邮件 <code>xuebi at gaoding.com</code> 联系。</blockquote><h2>参考</h2><ul><li data-pid="24z7kbHy"><a href="https://link.zhihu.com/?target=https%3A//vitejs.dev/guide/why.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why Vite - Vite</a></li><li data-pid="TGDo2cO2"><a href="https://link.zhihu.com/?target=https%3A//vitejs.dev/guide/dep-pre-bundling.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Dependency Pre-Bundling - Vite</a></li><li data-pid="1wiyAhgP"><a href="https://link.zhihu.com/?target=https%3A//vitejs.dev/guide/api-plugin.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Plugin API - Vite</a></li><li data-pid="NImibnRa"><a href="https://link.zhihu.com/?target=https%3A//vitejs.dev/config/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Features - Vite</a></li><li data-pid="U8GmPARQ"><a href="https://link.zhihu.com/?target=https%3A//vitejs.dev/config" class=" wrap external" target="_blank" rel="nofollow noreferrer">Configuring Vite - Vite</a></li></ul>