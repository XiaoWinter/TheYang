<p data-pid="-1MgoiBv">作为一名经常需要在团队中搞跨界合作的前端开发者，我发现许多往往被人们敬而远之的「底层」技能其实并不必学到精通才能应用。只要能以问题导向按需学习，就足以有效地完成工作，取得成果了。像 C、C++ 和 Rust 中的手动内存管理，就是这样的例子。我们完全可以绕开语言的黑魔法，只学习它们对工程而言最必要的特性与最佳实践。这就足够我们开发出它们与 JS 交互时的原生扩展，或调用平台库实现功能了。</p><p data-pid="DpdETUbm">因此，本系列文章将以实用和入门角度出发，专注于解释这几门「原生语言」中，与手动内存管理相关的子集。整个主题（暂定）依次包括这些部分：</p><ul><li data-pid="UXY-QJsj"><b>返璞归真：从引用类型到裸指针</b>——在 GC 的庇护下，我们对 JS 中引用类型（如对象）占用的内存可以放心地一无所知。那么如果想自己手动管理一段内存空间，这时最朴素最简单最经典的做法，是怎样的呢？令许多计算机专业新生「闻风丧胆」的指针，理解起来真的比 JS 困难很多吗？</li><li data-pid="YwTGX6-4"><b>新瓶旧酒：面向对象的资源管理</b>——原始的 C 语言是面向过程的，并不易于维护。在智能指针到来前，C++ 已为此投入了大量工作。我们是否能借此以更为声明式的代码和思想来管理资源呢？这时最常见的坑又是什么样的呢？</li><li data-pid="W3McGPmz"><b>半自动化：引用计数与智能指针</b>——无 GC 的内存管理只能完全手动吗？是时候接触现代 C++ 中的智能指针了。理想情况下只要利用好这套基础设施来写 C++，其开发效率未必会差 JS 太多（当然理想和现实是有差距的）。</li><li data-pid="SaRflzA1"><b>触类旁通：进入 Rust 时代</b>——最后，很多人在光有 JS 背景去硬啃 Rust 时，可能会遇到不少显得奇怪的语言特性。但有了上面的铺垫后，你或许就可以「秒懂」Rust 为什么要这么设计了。你会看到只要理解了原理，要把内存管理的经验在 C++ 和 Rust 之间复用，其实并非难事。</li></ul><p data-pid="0s67u2sa">由于在内存管理方面，JS 和其他常见的 Java、Python 和 Dart 等带 GC 语言的差别并不大。因此熟悉这些语言的同学，也可以很容易地按这篇文章介绍的方式，由浅入深地掌握这项工程技能。另外在前端开发者们常用的 macOS 上，C/C++ 的编译环境更完全是现成的，没有任何折腾的必要。本文中的代码都是无需第三方依赖的单线程简单示例，因此也不必接触复杂的构建配置和多线程心智模型。</p><p data-pid="YHWckwTQ">作为系列的起点，下面我们将从 JS 返回 C 的世界。有位做 C++ 的朋友提醒我说「<i>裸指针可能是最难的</i>」。但其实个人认为对现在<b>普遍熟悉强类型语言</b>的前端开发者们来说，裸指针反倒很容易通过一些技巧来快速类比掌握。不过鉴于指针的新人杀手性质，本文会尝试提供一条尽可能平滑的学习曲线。相信只要过了这一关，大家读起后面的内容会轻松顺利很多。</p><p data-pid="wpwxjg0t">本篇介绍可分为如下几个部分：</p><ul><li data-pid="FDxn7c2P">你可能已经掌握的 C 子集</li><li data-pid="lgacT40S">熟悉指针类型</li><li data-pid="-jjI6Km2">为指针分配内存</li><li data-pid="fYOfqlie">指针、数组与字符串</li><li data-pid="iL-5XD9_">指针与 C++ 中的引用</li></ul><p data-pid="JAXBjZXo">下面，让我们首先从每位前端开发者都耳熟能详的「基础类型」和「引用类型」说起吧。</p><h2>你可能已经掌握的 C 子集</h2><p data-pid="b0bQ642n">当我们探讨「原生」语言中的内存管理时，C 语言是我们很难绕开的话题。它的影响极为深远，以至于很多时候当你熟练地使用其他高级语言编码时，你甚至未必知道自己可能已经（部分地）学会了 C。比如，如果只考虑 <code>double</code> 和 <code>int</code> 这样的基础类型，那么你会发现这时的 C 语言，几乎不可思议地接近 JS 和 Dart。像下面这段用来计算斐波那契数列的经典代码，就同时既是有效的 C，又是有效的 Dart：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="YqZNCwZg">上面这个例子中，在发生形如 <code>fib(n - 1)</code> 的函数调用时，调用方 <code>n - 1</code> 表达式的值会被复制一份，传给被调用的函数，这也就是所谓 <a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Evaluation_strategy%23Call_by_value" class=" wrap external" target="_blank" rel="nofollow noreferrer">pass by value</a> 的经典心智模型了。对于整数和浮点数等「小」数据类型，这种设计从 C 时代起，一直在主流工业语言中沿用至今。所以如果你只用 JS 或 Dart 做这类纯粹的算术计算，那么你完全可以（自豪地）认为这时你写的代码就是 C 语言子集的一种方言变体，当然这个子集其实也没多少实用价值就是了。</p><blockquote data-pid="NgFISXN4">有些语言会把类型定义放在变量标识符前面，如 C、C++、Java、C# 和 Dart。也有一些则会把类型放在标识符后面，如 TypeScript、Rust 和 Go。像 <code>int x</code> 还是 <code>x: int</code> 这种风格问题本身并没有多少好坏之分，大家只要入乡随俗地习惯就行。</blockquote><p data-pid="3i15EQKE">根据小学二年级的前端知识，我们知道在 JS 中，整数和浮点数属于基本类型（<a href="http://link.zhihu.com/?target=https%3A//262.ecma-international.org/11.0/%23sec-primitive-value" class=" wrap external" target="_blank" rel="nofollow noreferrer">primitive values</a>），而对象则属于引用类型。所谓「引用」就像超链接一样，是个指向实际对象的标识符。在 JS 中，当我们把对象作为参数来执行函数调用时，引用会被复制一份传入被调用的函数，而引用所指向的对象本身则不会被拷贝——前端社区里解释这件事的文章早已汗牛充栋，这里就不再赘述了。关键的问题在于，在 C 语言里传递「对象」时又是怎样的呢？</p><p data-pid="PTjwE633">有趣的是，<b>如果我们坚持写语法最简单的 C，那么你会发现这时的 C 甚至在心智模型上能比 JS 更加简单</b>，简单到你都可以不用考虑「引用」这个常常困扰初学者的概念。实际上，当我们在 C 语言中使用 <code>int a</code> 这样的语法来定义变量时，数据通常会被分配在栈（此处指原生程序的运行时调用栈，即所谓的 <a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Call_stack" class=" wrap external" target="_blank" rel="nofollow noreferrer">The Stack</a>）上。这类变量的内存能做到被优雅地零开销自动管理，因为在离开函数作用域时，在栈上分配的内存都会被自动回收。而对于 C 语言中常用于模拟对象的 <code>struct</code> 结构体来说，默认你也能用这种方式来管理它的内存——<b>也就是完全不用你费心管</b>！没有内存泄漏，没有悬空指针，一切简单明了地自动完成。</p><p data-pid="Y8Y1NPOH">让我们举例说明这种「最简单的 C」吧。假设我们想基于 Skia 这样的 2D 图形绘制库，实现自己的 UI 框架。那么这时框架中所建模的最重要的抽象概念，应该就是屏幕上的矩形图层（这里把它称为 Layer）了。基于朴素的 C 结构体语法，我们可以这么建模图层 Layer 的基础结构：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 导入标准库中的 printf 函数</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="c1">// 定义名为 Layer 的结构体，包含 x y w h 四个字段</span>
<span class="k">struct</span> <span class="n">Layer</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">w</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">h</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 输出 layer 的宽高尺寸</span>
<span class="kt">void</span> <span class="nf">printSize</span><span class="p">(</span><span class="k">struct</span> <span class="n">Layer</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 使用 layer.xxx 语法来获取字段</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"width: %f, height: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 使用字面量语法建立栈上的 layer 实例</span>
  <span class="k">struct</span> <span class="n">Layer</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
  <span class="n">printSize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="VKBxO3lU">不过 <code>struct Layer</code> 这样的类型名有些啰嗦，所以我们常常会用 <code>typedef</code> 语法来简化一下它，像这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 把 struct Layer 定义为 Layer</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Layer</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">w</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Layer</span><span class="p">;</span>
</code></pre></div><p data-pid="3lTXC5nc">这样一来，我们就可以用 <code>Layer</code> 这个类型来替代 <code>struct Layer</code> 了：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">void</span> <span class="nf">printSize</span><span class="p">(</span><span class="n">Layer</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"width: %f, height: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
  <span class="n">printSize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="R6dNBIjT">基于这种语法，你甚至可以在 C 语言中轻松地获得纯粹的，无副作用的的纯函数。它完全通过返回值来输出计算结果，从而彻底避开 JS 函数内部直接 mutate 外部对象的问题：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 将某个 layer 的尺寸放大两倍</span>
<span class="c1">// 不同于 JS，这里传入的 layer 相当于原始值的拷贝</span>
<span class="n">Layer</span> <span class="nf">doubleSize</span><span class="p">(</span><span class="n">Layer</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 这里不会 mutate 原本的结构体数据</span>
  <span class="n">layer</span><span class="p">.</span><span class="n">w</span> <span class="o">*=</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="n">layer</span><span class="p">.</span><span class="n">h</span> <span class="o">*=</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">layer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
  <span class="c1">// 如果只调用 doubleSize(a) 而不赋值，是不会修改 a 的</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">doubleSize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">printSize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="cPrkGOas">遗憾的是，上面这种手法虽然看起来简单易懂，但真实的 C 工程项目中经常不会这么做。为什么呢？首先，这种传值形式可能在函数调用之间产生较多冗余的拷贝，影响程序的性能。并且有些资源（例如 GPU 纹理）甚至未必位于内存中，它们更是不可随意拷贝的。这时该怎么办呢？</p><h2>熟悉指针类型</h2><p data-pid="OUArCrwj">终于，是时候让我们讨论 C 语言中的「引用类型」了——通过引入「<b>指针</b>」的概念，C 语言赋予了你自由地引用和解引用内存地址的能力。传统上，指针常常让新手感到艰深晦涩。而某些应试教育中人为制造的 <code>int ****p</code> 等脱离实际的问题，更加深了普通人对其的畏惧感。但下面我们将介绍一种简单的技巧，展示如何通过引入一点点写法上的改变，让你即便只有 JS 系语言的使用经验，也能轻松地写出可以通过编译的指针操作代码。</p><p data-pid="Glzo1tVI">这条技巧说起来其实很容易，<b>那就是把指针当作一种特殊的变量类型即可</b>。你可以在任何类型的后面加一个 <code>*</code>，获得其相应的指针类型，像这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span> <span class="n">x1</span><span class="p">;</span> <span class="c1">// 定义出 int 类型的变量 x1</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// 定义出 int* 类型的变量 x2</span>
<span class="n">Layer</span> <span class="n">layer1</span><span class="p">;</span> <span class="c1">// 定义出 Layer 类型的变量 layer1</span>
<span class="n">Layer</span><span class="o">*</span> <span class="n">layer2</span><span class="p">;</span> <span class="c1">// 定义出 Layer* 类型的变量 layer2</span>
</code></pre></div><blockquote data-pid="a-vIMURN">为了便于理解，本文把指针类型以外的类型统称为「普通类型」。对所谓「普通类型」更准确的定义其实是「值类型」。C 语言中的值类型既包含整数和布尔值这样的基础类型，也包括了 <code>struct</code> 和 <code>enum</code> 这样的复合类型，在 C++ 中还包括了 <code>class</code>。<b>总之如果不使用指针，那么 C 语言并不像 JS 那样「对象就是引用类型」</b>。更详细的相关定义可参见 <a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Value_type_and_reference_type" class=" wrap external" target="_blank" rel="nofollow noreferrer">Wikipedia</a>。</blockquote><p data-pid="kay_0a0X">上面这种写法，看起来（至少在个人眼里）很贴近前端在使用 TypeScript 等强类型语言时的思维模型。但要注意的是，它其实和「经典」的 C 编程风格是有所不同的。传统上，C 语言代码中习惯使用 <code>int *p</code> 的风格来定义指针变量。其理由很简单，如下所示：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// 这里的 q 是 int 类型，不是 int* 类型！</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> <span class="c1">// 改成这样就不会写错</span>
</code></pre></div><p data-pid="S0uYMyFe">不过，个人认为使用 <code>int* p</code> 的风格，更有助于我们将指针概念融入大家现在所习惯的类型系统，降低一些学习成本。例如在谷歌 Chromium 项目中，就使用了这样的编码风格。基于这种风格，不论是整数、浮点数还是结构体，如果它们默认的类型是 <code>Type t</code>，那么 <code>Type* t</code> 就是其相应的指针类型。不管在哪种情况下，你定义出的变量名始终是 <code>t</code> 而不是 <code>*t</code>。</p><p data-pid="HlUWXsmb">按照这个「把指针当作一种变量类型」的理解方式，你会发现指针变量如果（十分鲁莽地）不考虑安全性问题，它们在使用时的心智负担实际上非常小。<b>具备指针类型的变量同样可以被重新赋值，也可以作为函数参数自由传递</b>。像这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 这个函数接收 Type* 类型的变量，这在 C 中非常常见</span>
<span class="kt">void</span> <span class="nf">renderLayer</span><span class="p">(</span><span class="n">Layer</span><span class="o">*</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Layer* 类型变量可以这样简单地定义出来</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
  <span class="c1">// Layer* 类型变量也可以用函数来创建，先忽略这里的细节</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">makeLayer</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>
  <span class="c1">// Layer* 类型变量之间可以自由地互相赋值</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="c1">// Layer* 类型变量也可以作为函数参数传递</span>
  <span class="n">renderLayer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="5igDYEab">看起来是不是也很简单呢？不过，指针类型和普通类型显然还是有所不同的。回到 Layer 的例子，<code>Layer*</code> 类型的指针变量在使用时相比于 <code>Layer</code> 类型的普通变量，其区别简单看来只有这么两条：</p><ul><li data-pid="VlChAI8X">指针类型变量，在函数调用之间传递的是引用的拷贝。</li><li data-pid="-gl5DT_x">指针类型变量，需要用形如 <code>obj-&gt;x</code> 的语法替代 <code>obj.x</code> 来存取值。</li></ul><p data-pid="9Y0MKGkX">体现这两条区别的例子是这样的：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">void</span> <span class="nf">doubleSize</span><span class="p">(</span><span class="n">Layer</span><span class="o">*</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 通过指针变量，可以直接 mutate 原本的结构体数据</span>
  <span class="n">layer</span><span class="o">-&gt;</span><span class="n">w</span> <span class="o">*=</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="n">layer</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">*=</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="n">printSize</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 先忽略创建 Layer* 类型变量时的细节</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">makeLayer</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>
  <span class="c1">// 因为传递的是引用，这里不再需要函数返回值了</span>
  <span class="n">doubleSize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="AJUcQlQq">在这个例子中，通过引入指针，我们使用 C 的方式已经发生了变化，能以引用类型的心智模型来编写逻辑了。不过，指针变量和普通变量之间并不直接兼容。这也就是说，需要 <code>Layer*</code> 变量的地方不能传入 <code>Layer</code> 变量，反之亦然。所幸它们之间可以简单地进行双向转换，其语法是这样的：</p><ul><li data-pid="cMuX6ls9">通过 <code>&amp;</code> 操作符，你可以把 <code>Layer</code> 类型转换成 <code>Layer*</code> 类型，亦即所谓的<b>引用</b>（reference）。</li><li data-pid="MWxB4dyy">通过 <code>*</code> 操作符，你可以把 <code>Layer*</code> 类型转换为 <code>Layer</code> 类型，亦即所谓的<b>解引用</b>（dereference）。</li></ul><p data-pid="mhFXg_K0">所谓的引用和解引用，其实很类似 Vue 3.0 中的 <code>ref</code> 和 <code>unref</code>。这种转换的编写本身并不需要额外的条件，只要类型匹配就能通过编译。其相应的例子类似这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">void</span> <span class="nf">printSize1</span><span class="p">(</span><span class="n">Layer</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"width: %f, height: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printSize2</span><span class="p">(</span><span class="n">Layer</span><span class="o">*</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"width: %f, height: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">layer</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">,</span> <span class="n">layer</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">makeLayer</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>
  <span class="n">Layer</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
  <span class="n">printSize1</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 将 Layer* 转为 Layer</span>
  <span class="n">printSize2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 将 Layer 转为 Layer*</span>
<span class="p">}</span>
</code></pre></div><h2>为指针分配内存</h2><p data-pid="IVpIUVkG">了解指针类型与普通类型之间的转换后，擅长活学活用的同学可能立刻就能想到，我们是不是可以像下面这样简单直接地实现 <code>makeLayer</code> 函数呢？</p><div class="highlight"><pre><code class="language-c"><span></span><span class="n">Layer</span><span class="o">*</span> <span class="nf">wronglyMakeLayer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span> <span class="n">layer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">layer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="IbyaG83-">不幸的是，虽然这段代码能通过编译，但它却犯了个严重的错误。我们把函数内部局部变量所在的内存地址传了出去，而这份分配在栈上的内存空间，在函数返回后就会直接被回收！因此即便能通过编译并有时「凑巧」能正常工作，这段代码也是有问题的，会收到现代编译器的警告。</p><p data-pid="E6wYBwDF">那么，到底该如何合法地创建出指针类型的复杂结构呢？这常常需要我们手动申请和销毁内存。C 函数自动管理的内存一般分配在栈上，而这类动态分配的内存则位于堆（<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Memory_management%23HEAP" class=" wrap external" target="_blank" rel="nofollow noreferrer">heap</a>）上。让我们来看看这个过程涉及到哪些 API 吧。</p><blockquote data-pid="A5czQ-fu">注意，指针既可以指向栈上的内存，也可以指向堆上的内存。栈上的变量只要还没被回收，创建指向它的指针来使用是完全合法的。但对于需要在函数返回后继续长期存在的内存，就必须手动在堆上申请了。</blockquote><p data-pid="GdzYm8xw">我们知道，要在 C 和 C++ 中使用库，需要引入相应的 <code>.h</code> 头文件。像 <code>stdio.h</code> 就包含了 <code>printf</code> 函数。对于内存分配，我们可以使用标准库 <code>stdlib.h</code> 中的 <code>malloc</code> 函数。只要为它传入所需的内存大小，就可以获得一个指向这段空间的 <code>void*</code> 类型指针了。可以认为 <code>void</code> 相当于 TypeScript 中的 <code>any</code>，因此 <code>void*</code> 也就是能指向任意类型数据的指针。C 语言中的类型转换规则较为宽松，这个 <code>void*</code> 类型变量可以被直接赋值给任意的指针类型，并需要用 <code>free</code> 函数销毁。至于 <code>malloc</code> 所需的具体字节尺寸数字，则可以通过 <code>sizeof</code> 关键字在编译期计算出来。像这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; // 导入用于手动管理内存的库函数</span><span class="cp"></span>

<span class="n">Layer</span><span class="o">*</span> <span class="nf">makeLayer</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 分配 Layer 所需尺寸的内存空间</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Layer</span><span class="p">));</span>
  <span class="n">layer</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">layer</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">layer</span><span class="o">-&gt;</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
  <span class="n">layer</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">layer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">makeLayer</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>
  <span class="c1">// ...</span>
  <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 用完记得 free 掉</span>
<span class="p">}</span>
</code></pre></div><p data-pid="6ga69FkD">除了 <code>malloc</code> 以外，C 标准中还有能将分配到的空间清零的 <code>calloc</code> 函数，以及能就地调节原指针指向空间大小的 <code>realloc</code> 函数。它们返回的都是 <code>void*</code> 类型的指针，可以用 <code>free</code> 销毁。并且在 C 里，我们还可以通过 <code>TypeB* b = (TypeB*)a</code> 这样的强制类型转换语法，把指向某段内存空间的指针映射到任意类型。但不论如何转换类型，对于指向某段内存地址的指针，其在 <code>malloc</code>/<code>calloc</code>/<code>realloc</code> 时所分配的内存空间，都能正确地被 <code>free</code> 掉。对此有种简单易懂的理解，就是认为 <code>free</code> 既然接受的是 <code>void*</code> 类型，它到底要释放多少内存空间显然与特定类型无关。不过这背后更具体的原理，则在《Operating Systems: Three Easy Pieces》中有很精彩的论述，推荐感兴趣的同学阅读。</p><p data-pid="CptvXpbe">当然，如果觉得指针只要学会了 <code>malloc</code> 和 <code>free</code> 就能用好，那就太小看它了。C 中原始的裸指针机制，非常容易带来一些棘手的问题。前面我们说到过，所谓「引用」就像 URL 超链接一样，是个指向实际内容的标识符。而在没有 GC 当保姆的时候，这种标识符机制所产生的问题，和我们日常上网使用超链接时遇到的很像。比如这么几种：</p><ul><li data-pid="3q2M-8Sv"><b>使用了未初始化的指针</b>，即所谓野指针（wild pointer）——相当于链接生成后还没准备好内容就点开，于是页面一片空白。</li><li data-pid="RgokPFP1"><b>使用了已经被释放的指针</b>，即所谓悬空指针（dangling pointer）——相当于原页面被删除但链接却留着，于是一点开链接就是 404。</li><li data-pid="qTaZcA0G"><b>内存泄漏</b>——相当于链接被遗忘了，于是某个页面虽然已经没有价值，却没有被及时删除掉。</li></ul><p data-pid="QVddO8JJ">如何感受指针的危险呢？在 JS 中，我们常用一个对象是否为 <code>null</code> 来判断它是否存在。这种「天经地义」的效果在 C 中是不成立的。虽然 C 中有 <code>NULL</code> 宏，但一旦出现悬空指针和野指针，它们都可以通过 <code>NULL</code> 检查！比如这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">void</span> <span class="nf">renderLayer</span><span class="p">(</span><span class="n">Layer</span><span class="o">*</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 常见的防御判断对悬空指针无效！</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">makeLayer</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="c1">// 这时的 a 不为 NULL，它是个悬空指针</span>
  <span class="n">renderLayer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="-iAP4X1J">如果把失效的地址拿来解引用，很容易导致程序的运行时崩溃。诸如此类的各种问题使得指针虽然容易通过编译，准确地用好它却很难——不过作为手动内存管理的元祖级特性，现在我们至少已经知道该怎么理解和编写它了。并且对前端开发者而言，就算还没有指针的实际工程经验，只要借助对其概念的理解，C 的许多重要语言特性一下就会显得很简单了。</p><h2>指针、数组与字符串</h2><p data-pid="ax7hlrwS">在经典的谭书等 C 语言教材中，是先讲字符串和数组，再讲指针的。如果把 C 作为第一门编程入门语言，这个安排有其合理性。但本文并未遵循这条路线，<b>因为只要我们先从 JS 的引用类型出发理解了 C 的指针类型，很容易继续把 C 的数组当作一种指针来理解，进而理解字符串的结构</b>。</p><p data-pid="heZ0tGEo">首先，指针是可以和整数之间做加减运算的——对具备「对象是引用类型，数字是基本类型」经验的前端同学来说，这恐怕有点毁三观。毕竟基于 JS 的思维模式，<code>obj + 1</code> 难道不应该是……<code>"[object Object]1"</code> 吗？但在 C 语言里，这是极为重要的指针运算。假设我们为某种类型的 N 个实例分配了一整段内存空间，而这段空间的起始位置又有个指针。那么我们就可以用这种方式，指向其中的某个实例：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 在堆上分配足够容纳 5 个 Layer 的内存空间</span>
<span class="n">Layer</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Layer</span><span class="p">));</span>

<span class="c1">// 可以直接解引用出第一个 Layer</span>
<span class="n">Layer</span> <span class="n">first</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="c1">// 或获得指向第二个 Layer 的指针</span>
<span class="n">Layer</span><span class="o">*</span> <span class="n">secondA</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 也可以这样解引用出第二个 Layer</span>
<span class="n">Layer</span> <span class="n">secondB</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div><p data-pid="cwNyQn7I">但是，上面 <code>*(p + 1)</code> 这种写法实在太不语义化了。为此 C 设计了数组语法，可以给指针操作披上一层壳：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 在栈上分配 5 个 Layer 实例</span>
<span class="n">Layer</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>
<span class="n">Layer</span> <span class="n">layers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">};</span>

<span class="c1">// 这比 *(p + 1) 直观多了吧</span>
<span class="n">Layer</span> <span class="n">second</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div><p data-pid="4lxtoois">可以看出，<code>*(ptr + offset)</code> 等价于 <code>ptr[offset]</code>，而这个 <code>offset</code> 每次 <code>+1</code> 时对应的字节数，正是 <code>ptr</code> 所指类型的 <code>sizeof</code> 大小。比如假设 <code>sizeof(Layer)</code> 的结果是 32，那么 <code>layers[2]</code> 就等价于偏移 <code>2 * 32</code> 个字节的内存地址——<b>这种简单明了的对应关系，其实也是 C 语言从零开始计算数组下标的原因之一</b>。除了 <code>[]</code> 以外，前面提到的 <code>-&gt;</code> 运算符也有这样的语法糖性质，<code>obj-&gt;x</code> 实际上就等价于 <code>(*obj).x</code>。</p><p data-pid="E9ZbhSkq">对于装载任意类型数据的 C 数组，你都可以创建出指向它的指针。如果数组的类型是 <code>Type[]</code>，那么相应指针的类型就是 <code>Type*</code>。并且，数组和指针都能用 <code>[]</code> 运算符来取下标。像这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// int[] 类型的数组</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="c1">// int* 类型的指针，指向数组起始位置</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>

<span class="c1">// 下面这两行代码是等价的</span>
<span class="kt">int</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div><p data-pid="zVJTIAxi">别忘了 <code>int</code> 和 <code>Layer</code> 都属于值类型，所以我们也能轻松照猫画虎地写出这样的代码：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="n">Layer</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="c1">// Layer[] 类型的数组</span>
<span class="n">Layer</span> <span class="n">layers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">};</span>
<span class="c1">// Layer* 类型的指针，指向数组起始位置</span>
<span class="n">Layer</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">layers</span><span class="p">;</span>

<span class="c1">// 下面这两行代码也是等价的</span>
<span class="n">Layer</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">Layer</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div><p data-pid="1lErMhRL">更进一步地，数组里可不只能装普通类型，也能装指针类型：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="n">Layer</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Layer</span><span class="p">));</span>
<span class="n">Layer</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Layer</span><span class="p">));</span>

<span class="c1">// 数组中的每项都是 Layer* 类型</span>
<span class="n">Layer</span><span class="o">*</span> <span class="n">layers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">};</span>
<span class="c1">// 等效的指针形式，指向数组起始位置</span>
<span class="n">Layer</span><span class="o">**</span> <span class="n">p</span> <span class="o">=</span> <span class="n">layers</span><span class="p">;</span> 

<span class="n">Layer</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 等价于 p[0]</span>
<span class="n">first</span> <span class="o">==</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// true</span>

<span class="c1">// 记得销毁 malloc 出的对象</span>
<span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</code></pre></div><p data-pid="9_Oiw0VD"><code>Layer**</code> 这个类型可能有些费解，它的字面意义是 <code>Ptr&lt;Ptr&lt;Layer&gt;&gt;</code>，在实践中既可以兼容 <code>Ptr&lt;Array&lt;Layer&gt;&gt;</code>，也可以兼容 <code>Array&lt;Ptr&lt;Layer&gt;&gt;</code>，我们这里使用的是后者。<b>不要再纠结于传统 C 语言教程中所谓「数组指针」和「指针数组」这种含糊的概念了。直接从类型的角度理解它们，会准确而可靠得多</b>。</p><p data-pid="oCU5Qt4Q">C 中的数组非常简单，它纯粹只是一段连续的内存空间，并不携带长度信息。在将数组作为函数参数传递时，一般还要单独将其长度作为参数传递。这时候它们对外的 API 形式也都很接近：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="c1">// 接收数组为参数的函数</span>
<span class="kt">void</span> <span class="nf">printArr</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 数组的最后一项</span>
<span class="p">}</span>

<span class="c1">// 等价的指针形式，虽可用但语义化程度较差</span>
<span class="kt">void</span> <span class="nf">printPtr</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 数组的最后一项</span>
<span class="p">}</span>
</code></pre></div><p data-pid="oKHf-ABa">为什么 <code>int arr[]</code> 好像总能转换成 <code>int* arr</code> 来使用呢？实际上在需要指针类型的地方，C 会将数组类型自动退化（decay）为指针类型。因此 <code>int[]</code> 和 <code>int*</code> 虽然类型不同，但需要 <code>int*</code> 的地方总可以传入 <code>int[]</code>。</p><p data-pid="sSXHtSK9">既然 <code>int[]</code> 和 <code>int*</code> 的兼容性这么好，<code>char[]</code> 和 <code>char*</code> 自然也不例外——<b>然后我们就可以很容易地理解 C 中的「字符串」了</b>。C 中从来没有 <code>string</code> 类型，只有用来表示单个字节的 <code>char</code> 类型。于是，由一串 <code>char</code> 类型字符数据组成的数组，就构成了「真 · 字符串」。假设我们要为 Layer 增加 <code>name</code> 字段，就可以直接这么写：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Layer</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">w</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">h</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span> <span class="c1">// 预留 50 字节的位置</span>
<span class="p">}</span> <span class="n">Layer</span><span class="p">;</span>
</code></pre></div><p data-pid="ewmFfXu3">或者把 <code>char[]</code> 换成不受长度限制的 <code>char*</code> 类型：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Layer</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Layer</span><span class="p">;</span>
</code></pre></div><p data-pid="7W2Lw2Z-">这两种形式都可以这么初始化：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="n">Layer</span> <span class="n">a</span><span class="p">;</span>
<span class="n">Layer</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">};</span>
</code></pre></div><p data-pid="Y2rmbdcn">但 <code>char[]</code> 有个地方需要注意，那就是它不能被重新赋值。比如这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Layer</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Layer</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span> <span class="n">layer</span><span class="p">;</span>
  <span class="n">layer</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span> <span class="c1">// 但这是无法通过编译的</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">layer</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span> <span class="c1">// 要换成这样</span>
<span class="p">}</span>
</code></pre></div><p data-pid="lL9YaQcv">相比之下，<code>char*</code> 就没有这种限制：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Layer</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Layer</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span> <span class="n">layer</span><span class="p">;</span>
  <span class="n">layer</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span> <span class="c1">// 这样可以通过编译</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">layer</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span> <span class="c1">// 这样也可以</span>
<span class="p">}</span>
</code></pre></div><p data-pid="p0uhXxur">除了赋值时的区别外，C 中的字符串也不能靠 <code>==</code> 来比较。<code>==</code> 只能用于比较指针和算术类型。如果直接比较两个 <code>char[]</code> 数组，这时虽然可以通过编译，但 C 会将数组退化为指针来进行比较，其结果并不是我们想要的。因此不管是 <code>char[]</code> 还是 <code>char*</code> 类型的字符串，其通用的比较方式都是使用 <code>string.h</code> 标准库中的 <code>strcmp</code> 函数。</p><blockquote data-pid="-d9prYun">另外，前面的结构体 <code>Layer</code> 类型也不能用 <code>==</code> 来比较，只有 <code>Layer*</code> 可以。不妨想想这是为什么，又该怎么办呢？</blockquote><p data-pid="MsrEmUyt">我们已经发现，字符串既可以是 <code>char[]</code> 类型，也可以是 <code>char*</code> 类型。这里存在一个容易混淆之处，亦即字符串的存储位置。像下面的三行代码虽然同属 <code>char</code> 家族，但它们运行时所处的内存区域却各不相同：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span> <span class="c1">// 分配在栈上</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 分配在堆上</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span> <span class="c1">// 指针 c 在栈上，"world" 在常量区</span>
<span class="p">}</span>
</code></pre></div><p data-pid="zg4PYYLN">上面的例子，反映出了 C 中字符串可能对应的几种内存分配位置：</p><ul><li data-pid="kYE1wUfk"><b>栈上</b>：对于 <code>"hello"</code>这样赋值给 <code>char[]</code> 的字符串，它和 <code>int a[] = {1, 2, 3}</code> 一样，整个数组内的数据都是分配在栈上的。</li><li data-pid="mmb0XAfF"><b>堆上</b>：对于 <code>malloc</code> 动态分配出的字符串空间，自然分配在堆上。如果想动态改变这类字符串的长度，还可以通过 <code>realloc</code> 来实现。不妨将此留作习题（狗头）。</li><li data-pid="9q04repH"><b>常量区上</b>：对于 <code>"world"</code> 这样直接赋值给 <code>char*</code> 的字符串字面量，一般在程序运行过程中始终位于固定的内存空间，因此不需要操心它的释放。但注意指针 <code>c</code> 本身也是个函数内的局部变量，因此它分配在栈上。<code>c</code> 本身可以通过栈的内存管理来自动销毁，但它指向的东西则不行——其他指针也是这么个道理。</li></ul><p data-pid="9ZMmTa5Q">在这里，我们可以再次感受到 C 的抽象层次之低。作为入门性质的文章，这里不会继续深入相关的 OS 和编译产物细节。不过至少目前来看，这个例子可以告诉我们，为什么有些地方传来的字符串需要手动销毁，有些则不需要了。</p><h2>指针与 C++ 中的引用</h2><p data-pid="QnKaYVEr">上文已经覆盖了对指针常用知识的基本介绍。在传递引用方面，C 为我们提供的特性实质上也就只有它了。但对于「引用类型」这个概念，最后值得简单一提的还有 C++ 中的引用（reference）语言特性。</p><blockquote data-pid="fbAWQVpt">C++ 中的引用和 C 的指针，都可以认为是（相对于值类型的）引用类型。本文中除非特别提及，所谓「引用类型」都指广义上的通用概念，而不是 C++ 中的这项具体语言特性。</blockquote><p data-pid="EraxXMMt">经过上面的论述，我们已经知道对于 <code>Layer</code> 这个类型，存在着 <code>Layer*</code> 和 <code>Layer[]</code> 这两种引用类型了。C++ 中加入了一种新的类型，那就是 <code>Layer&amp;</code>。像这样：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">Layer</span> <span class="n">a</span><span class="p">;</span>
<span class="n">Layer</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// 创建一个 Layer&amp; 类型变量</span>
</code></pre></div><p data-pid="abfaUN2b">或许不少人只要一看到带着 <code>&amp;</code> 和 <code>*</code> 的类型就头疼。不过这里有条好消息，那就是 <code>Layer&amp;</code> 类型可以当做普通的 <code>Layer</code> 类型来用！像这样：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="kt">void</span> <span class="nf">printSize</span><span class="p">(</span><span class="n">Layer</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"width: %f, height: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Layer</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">Layer</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

  <span class="c1">// Layer 和 Layer&amp; 的存取值语法一样</span>
  <span class="n">a</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">;</span>
  <span class="n">b</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mf">200.0</span><span class="p">;</span>

  <span class="c1">// 作为参数传递时的用法也一样</span>
  <span class="n">printSize</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">printSize</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p data-pid="KCdaed0s">这么看来，这种类型有什么存在的意义呢？它的名字已经告诉了我们答案，那就是「引用」能力了。如果我们写的是朴素的 <code>Layer b = a</code> 而非 <code>Layer&amp; b = a</code>，那么这里的 <code>a</code> 和 <code>b</code> 是两个独立的实例，对 <code>b</code> 的修改不会影响 <code>a</code>。而对于 <code>Layer&amp;</code> 类型的 <code>b</code> 来说，对它的修改也会直接影响到 <code>a</code>。这个差异应该很容易理解，这里就不展开赘述了。</p><p data-pid="FdZdAAl3">C++ 引用特性的一种常见用途，是优化函数传参时的拷贝开销。刚才我们用来接收 <code>Layer</code> 的函数是这样的：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="c1">// 接收普通的值类型，会产生拷贝</span>
<span class="kt">void</span> <span class="nf">printSize</span><span class="p">(</span><span class="n">Layer</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div><p data-pid="fyGlf5Ib">每次调用这个函数时，传入的 Layer 数据都会被完整地拷贝一份。为此，我们可以把输入参数的类型从 <code>Layer</code> 换成 <code>Layer&amp;</code>——由于 <code>Layer</code> 和 <code>Layer&amp;</code> 之间的良好兼容性，这个改动应该不会报错。于是我们只要加一个 <code>&amp;</code> 就能优化掉拷贝开销，其他地方还是和原来一样该怎么写怎么写，属于躺着就能拿到的性能优化：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="c1">// 接收引用类型，能避免拷贝，但 layer 可能被 mutate</span>
<span class="kt">void</span> <span class="nf">printSize</span><span class="p">(</span><span class="n">Layer</span><span class="o">&amp;</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div><p data-pid="_VOwn4EH">但这时候，代码的潜在限制就会发生改变了。比如，我们现在可以通过修改 <code>layer.x</code> 来改变原有的数据，这就产生了代码语义上的差异。为此，我们可以继续用 <code>const</code> 修饰符来禁止修改它。这样一来，我们就得到了在许多 C++ 代码库中非常常见的这种函数：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="c1">// 接收常量引用类型，它不仅能避免拷贝，layer 还不会被 mutate</span>
<span class="kt">void</span> <span class="nf">printSize</span><span class="p">(</span><span class="k">const</span> <span class="n">Layer</span><span class="o">&amp;</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div><p data-pid="OxlwiJMa">当作为函数形参时，<code>Layer</code> 类型和 <code>const Layer&amp;</code> 类型的使用效果几乎是一致的：不用担心传入的变量被修改，也都能用 <code>layer.x</code>  的语法来读取值。并且相比于传递朴素的值类型，传递 <code>const</code> 引用可以避免拷贝——所以，下次在 C++ 函数参数列表里见到 <code>const Type&amp;</code> 类型的时候不要慌，它想表达的就是个更好的 <code>Type</code> 类型而已。</p><p data-pid="-9DUcljY">为了解决指针的常见问题，引用做出了几条限制：</p><ul><li data-pid="wXnHQ6L5">引用必须定义时就初始化，杜绝了 <code>int&amp; x;</code> 这样会导致野指针的写法。</li><li data-pid="4asGUDfQ">引用所绑定的对象是固定的。比如 <code>Layer&amp; b = a</code> 之后，<code>b = x</code> 的意思实际上就是 <code>a = x</code>。</li><li data-pid="u8YRNwcq">引用不允许赋值为 <code>NULL</code>。</li></ul><p data-pid="vMkjiQuf">引用算是相当容易应用的 C++ 特性。只要你在朴素的 C 代码库里用上它，那么你就可以说自己写的已经不再是 C，而是「C++ 的子集」了……后面我们也会继续按这种思路，按需地引入 C++ 中的一些重要概念。</p><p data-pid="dzF_8PxC">到这里，与 C 系语言中「引用类型」相关的介绍就到此为止了。总结如下：</p><ul><li data-pid="IhNg-g-z">C 语言离普通前端开发者其实并没有那么遥远，你很可能早已掌握了它的一个子集。</li><li data-pid="F1Z5Fn9K">C 最朴素的玩法甚至可以比 JS 更简单，同样能全自动且安全地管理内存。</li><li data-pid="hWDukzfk">指针相当于需要手动管理内存的引用类型变量。通过一点技巧，同样很容易用 C 写出合法（能通过编译）的指针操作代码，但别忘了安全问题。</li><li data-pid="E6q575bb">C 的数组可视为指针的语法糖，而字符串相当于 <code>char*</code> 或 <code>char[]</code>。</li><li data-pid="PlkwtsAX">C++ 增加了引用的概念。它和指针同属引用类型但更加安全易用，可在适合时作为替代。</li></ul><p data-pid="y6sk59Go">依靠本文目前介绍的 C 特性的表达力，已经足够高手用清晰的代码开发出强大的软件。比如哪怕只基于本文涉及的这么一点东西，你在阅读 Fabrice Bellard 的 QuickJS 引擎源码时，恐怕都已经不会受到多少语言特性上的困扰了。但 C 本身作为「最简单的高级语言」，其特性实在还是太少。它的继任者 C++ 做出了很多努力，便于我们靠更高层面的心智模型来开发大型项目。在下一篇文章中，我们会继续从 JS 背景开发者的视角出发，介绍在披上「面向对象」外衣时，原生语言中的内存管理是什么样的。</p><hr><p data-pid="EVdUQ19t">本系列文章计划在「前端随想录」专栏和 GitHub 上的 <a href="http://link.zhihu.com/?target=https%3A//github.com/fe-fantasy/gui-engineering-101" class=" wrap external" target="_blank" rel="nofollow noreferrer">gui-engineering-101</a> 仓库上连载并维护。这个《写给前端的 GUI 工程基础入门》电子书项目才刚刚启动，旨在分享一系列务实的工程技能入门介绍，例如上一个主题就是「<a href="https://zhuanlan.zhihu.com/p/340410273" class="internal">写给前端的原生开发基础入门</a>」。限于个人能力，文中介绍难免存在偏差和错漏，衷心希望大家批评指正（和顺便 star）。</p><p data-pid="fD-CWjyQ">版权声明：本文不允许未授权转载。</p>