<p data-pid="bdeBXlio">我今年的主要工作之一就是给我司线上的编辑器添加实时协作支持，这里面撤销重做的方案（嘴上）说起来倒也简单，因为核心的设计准则其实只有两条：</p><ol><li data-pid="TUn9xdxT"><b>用户只能撤销自己的改动</b>，这个对其他人状态的命运有很大的关系。</li><li data-pid="Fc_-x9Ep"><b>用户从状态 A 独立撤销 N 次之后再重做 N 次，要能回到 A</b>。注意这条规则并不只是一条产品需求，更是一条重要的技术需求。</li></ol><p data-pid="PqfVLuQf">只要这两条规则就够了吗？相信很多同学应该马上就会开始尝试找一些奇怪的边界条件来验证了吧——没错，确实是会有「<i>奇怪的状态</i>」。举个非常典型的例子：假设现在我们有 <code>A B C D</code> 四条 operation（也可以理解成 git commit），上述规则完全允许我们独立撤销掉 <code>C</code>，形成 <code>A B D</code>——这表明现在的历史记录已经不再是严格的栈了。因为多人协作编辑时，<b>任何一个闭麦很久的人都可以随时撤销自己很早之前的上一次改动</b>，这就相当于把压在栈底的任意一个状态抽掉。</p><p data-pid="2mNOJPr4">如果你熟悉西方 git 的那一套理论，可能会认为对于这种「釜底抽薪」的场景，需要做一些类似 rebase 的操作。确实，有一些社区产品（如 ProseMirror 作者自己研发的配套协作库）使用了类似的方案，但这其实并非当前业界的主流。作为替代，上面的第二条规则其实可以理解成「<b>回放可互相抵消的 operation 逆操作</b>」：我们需要保证的是对任意 operation <code>X</code> 都能获得其逆操作 <code>X'</code>，使得 <code>X X'</code> 能互相抵消，这样就可以了。</p><p data-pid="Ui8PJCEr">只要我们确定了这个方向，那么这时对于上述场景，就相当于只要对 <code>C</code> 计算出其逆操作 <code>C'</code>，然后获得 <code>A B C D C'</code> 即可——注意这个状态未必等价于理想中的 <code>A B D</code>，但是你放心在一些学术研究的黑魔法帮助下，这种做法仍然能保证状态的可用性。</p><p data-pid="K8wf547p">再稍微具体地演示一下这条规则吧。假设 <code>A B C</code> 都是来自同一个人的编辑，那么我们就应该能依次把 <code>C B A</code> 逐个给 undo 掉。如果接下来再继续做三次共轭的 redo 操作，那就相当于把 <code>A B C</code> 再应用回来。这时的状态变化过程是这样的：</p><ul><li data-pid="1EYODcsj">先逐个把 <code>C B A</code> 都 undo 掏空，获得 <code>A B C D C' B' A'</code>。</li><li data-pid="vnytuUaO">然后 redo 重做 <code>A B C</code>，获得 <code>A B C D C' B' A' A B C</code>。</li><li data-pid="pUtndpfz">上面的 <code>A A'</code> 会抵消，所以上面这串状态等价于 <code>A B C D C' B' B C</code>。</li><li data-pid="E-CsOjKp">再把上面的 <code>B' B</code> 消一次，获得 <code>A B C D C' C</code>。</li><li data-pid="fO4KvYUF">再把上面的 <code>C' C</code> 消掉，我们就回到了 <code>A B C D</code>。</li></ul><p data-pid="YS8W1vgo">做完这个消消乐之后我们不难发现，我们并不必关心独立撤销掉 <code>C</code>（也就是应用 <code>C'</code>）之后获得的是不是严谨的 <code>A B D</code>，应该关心的是在后续 redo 掉这次撤销（即再次应用 <code>C</code> 之后），状态要能够回到 <code>A B C D</code>——只要做到这点，不用修改既有历史就能建立正确的集体记忆了。</p><p data-pid="mLrO18rS">其实上面两条规则并不是我们的原创，而是业界总结出来的。如果你读过 <a href="http://link.zhihu.com/?target=https%3A//www.figma.com/blog/how-figmas-multiplayer-technology-works/" class=" wrap external" target="_blank" rel="nofollow noreferrer">How Figma’s multiplayer technology works</a> 这篇文章，就会发现上面讲的完全就是 Evan Wallace 巨巨这里想传达的意思：</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-5644044aea969a0453788e1a91a20f25_720w.jpg?source=d16d100b" data-rawwidth="1448" data-rawheight="786" data-size="normal" data-original-token="v2-5644044aea969a0453788e1a91a20f25" data-default-watermark-src="https://picx.zhimg.com/v2-f52f41d27500b7a7a1731b10aa7307dc_720w.jpg?source=d16d100b" class="origin_image zh-lightbox-thumb" width="1448" data-original="https://picx.zhimg.com/v2-5644044aea969a0453788e1a91a20f25_720w.jpg?source=d16d100b"><figcaption>按照这条基本法来就行</figcaption></figure><p data-pid="-u3cF3oy">不过，这种不遵守后进先出顺序的撤销重做自然可能产生冲突，<b>但冲突问题并非在历史记录模块的层面上解决</b>。作为简单介绍，注意现在我们有两种关键的数据结构，一种叫 <b>operation</b>（也就是像 redux 那样序列化出你的每次操作到底是 <code>add_element</code> 还是 <code>change_element</code> 之类），一种则是我们熟悉的 <b>model</b>——相应地在学术界，冲突解决算法也分成了两个流派：要么是以 operation 为抓手，打通对轻量 operation 数据的变换（<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Operational_transformation" class=" wrap external" target="_blank" rel="nofollow noreferrer">Operational Transform</a>，即 OT），要么是以 model 为抓手，实现出可以任意拥抱变化的 model 数据结构（<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Conflict-free_replicated_data_type" class=" wrap external" target="_blank" rel="nofollow noreferrer">Conflict-free replicated data type</a>，即 CRDT）。这两种玩法都有很多「形成闭环赋能业务」的成功案例，相应的论文读起来可能也比较容易击穿外行的心智。这方面其他回答里有些基本的科普，这里就不展开了。</p><p data-pid="7qitrUtX">从这个角度来看，我们可以认为这里介绍的历史记录管理方案是独立于（也依附于）OT 或 CRDT 这样的冲突解决算法的。如果你是为现有编辑器接入实时协作功能的开发者，那么这个模块根据 <a href="http://link.zhihu.com/?target=https%3A//martinfowler.com/eaaDev/EventSourcing.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">event sourcing</a> 的经典实践来设计就可以实现了（比如 redux 干的事情实质上就是一种 event sourcing）。当然这里也有现成的东西，比如社区库 Yjs 就提供了一个 <a href="http://link.zhihu.com/?target=https%3A//docs.yjs.dev/api/undo-manager" class=" wrap external" target="_blank" rel="nofollow noreferrer">UndoManager</a>，帮你做了上述工作。它的工作原理就完全与上述两条规则一致，即为每个用户（origin）维护一个本地的 undo 栈，对 undo 前后两份 model 状态做 diff，然后将这个 diff 发给我们（工程上它算是使用了 QuillJS 中 <a href="http://link.zhihu.com/?target=https%3A//quilljs.com/docs/delta/" class=" wrap external" target="_blank" rel="nofollow noreferrer">delta</a> 格式的一个超集）。因此对于这样基于 Yjs 实现的实时协作项目，我们其实是把 CDRT 库的 model 层当作了所谓的 <a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Single_source_of_truth" class=" wrap external" target="_blank" rel="nofollow noreferrer">single source of truth</a>。</p><p data-pid="3EreSIiM">既然已经提到了 OT 和 CRDT 的对比，这里就顺便多说一句：<b>在 2021 年，这个领域的未来已经明显是属于 CRDT 的了</b>。除了易于实现可横向扩展的服务端、易于实现端到端加密协作、性能问题已经基于 Yjs 算法得到大幅优化（<a href="http://link.zhihu.com/?target=https%3A//josephg.com/blog/crdts-go-brrr/" class=" wrap external" target="_blank" rel="nofollow noreferrer">参见这篇文章</a>）之外，还有一条大家喜闻乐见的八卦：你知道前端最流行的开源 OT 库叫 ShareDB 吗？而它的作者 Joseph Gentle 在去年写了一篇 <a href="http://link.zhihu.com/?target=https%3A//josephg.com/blog/crdts-are-the-future/" class=" wrap external" target="_blank" rel="nofollow noreferrer">CRDTs are the future</a> 的文章以后，现在正忙着把 Yjs 重写到 Rust 极致优化性能呢……</p><p data-pid="B2XbZ98n">最后，undo 和 redo 的实现只是整个协同编辑方案中的难点之一。对于一个真正可用的实时协作编辑器，还有很多需要理解和重视的细节。作为预告，我会就这个主题在今年 12 月的阿里 D2 上做一次比较全面的介绍，欢迎到时交流。</p><hr><p data-pid="maCAPV9x">话说大家读相关 paper 前不妨补一下这本书：</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1446873536099303424"></a><p></p>