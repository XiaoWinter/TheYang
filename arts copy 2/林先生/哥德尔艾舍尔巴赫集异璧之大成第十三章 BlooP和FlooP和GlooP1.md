<h2>1、自我意识和无序</h2><p data-pid="wLgOIqyn">BlooP、FlooP和GlooP是三种计算机语言，他们是专门为本章创造出来的，目的在于揭示“递归”的内涵。有助于阐明TNT中的自我相关的机制。</p><p data-pid="Qh3oSfgG">从意识的探讨跳到了TNT的探讨，并不是无意义，相反对于揭露出TNT的特性是有意义的。关于TNT的自我意识，令人惊奇的一点在于，他密切地联系了自然数的有序和无序问题。并且我们会发现，一个充分复杂的，以至于能够反映自身的有序系统不可能是完全有序的，必然包含着某种无序性。</p><p><br></p><h2>2、可体现性与冰箱</h2><p data-pid="fsHi9EZV">所谓“足够复杂”和“足够强有力”，是什么意思呢？</p><p data-pid="dMDboE0u">假设说TNT是足够强的，就好比在说唱机的保真度足够高，以至于能够重现唱片的声音。</p><p data-pid="YJgnkXXd">而说TNT是一个形式化的N，原因是说TNT的符号以正确的方式活动，他能够揭示出N中的真理。</p><p data-pid="bf80w4Vr">那么这里的核心真理是什么呢？他们是原始递归真理，指的是他们仅仅涉及到可以判定终止的计算，他们的意义如同欧几里得的公设，使得我们预先排斥掉那些力量不够强的可能性。</p><p><br></p><h2>3、元数学中的岩头之斧</h2><p data-pid="2QUeD543">而我们可以获得如下的事实，即如果你有数论的一个足够强有力的形式化体现，那么哥德尔定理就是可应用的，结果你的系统即是不完备的。另一方面，如果你的系统不是足够强有力的（即不是所有原始递归真理都是定理），那么你的系统由于有这个缺陷，也是不完备的。实际上，人们发现很弱的系统依然是会受到哥德尔方法攻?的。</p><p><br></p><h2>4、选择适当的过滤器来发现有序</h2><p data-pid="4DcpVgeF">我们通过哥德尔配数，可以显示出任何对一个具有特殊的符号性质的串的搜索都有一个算数中的同构关系，实现对一个具有相应的特殊算术性质的整数的同构搜索。</p><p data-pid="mIwIFcci">这里就好像是有一个过滤器，譬如说自然规律，自然规律恰恰是以这种方式被发现的。自然只是提供给我们大量的现象，它们表面上杂乱无章，直到我们选择了某些有意义的事件，而且把它们从特定的，关系不大的环境中抽象出来，使它们成为理想化的时候为止。只有那时它们才会展现出光彩夺目的真实结构。</p><p data-pid="JZZbsqYI">由此看来当我们设法理解自然时，我们应当把现象看作待理解的消息。只不过每个消息在我们为它设立一种编码之前好象是随机的。这种编码表现为一种抽象，就是说，我们有选择地把某些无关的东西忽略掉，这样就通过一种自由选择选取了消息的部分内容。这些无关信号构成了“背景噪声”，它们将限制我们的消息的精确性。</p><p data-pid="4Nt89uU5">但由于这种编码不是绝对的，在同一组作为原材料的数据中就可能存在着多个消息，因此改变编码就会在某些以前认为只是噪声的东西中发现同样深刻的意义。相反地，在新的编码中以前的消息可能会变得没有意义。</p><p data-pid="pWcMyMEb">我们不禁会问，自然是无序的还是模式化的？智能在确定这个问题的答案的过程中能起什么作用？</p><p><br></p><h2>5、BlooP语言的基本步骤</h2><p data-pid="xeQwWR_U">我们的任务是搜寻各种性质的自然数，为了讨论任意搜索的长度”，我们必须定义一些基本“步骤”，任何搜索都由它们组成。</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-42b4a9453b92285314388394fd552e98_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="286" data-rawheight="163" class="content_image" width="286"></figure><p><br></p><p><br></p><h2>6、循环和上界</h2><p data-pid="l5Ld_P9e">如果我们想用这些步骤严格地构造一个测试，例如测试一个数是否是素数，我们很快就会发现必须在其中包含一个“控制结构”——即对操作次序的描述：何时需要回过头来重新尝试某些东西，何时跳过一些步骤，何时停止，以及诸如此类的事情。</p><p data-pid="muSB2toL">所以一个算法，包含着两个成分，</p><p data-pid="HJs6jL_v">（1）需完成的特定运算</p><p data-pid="VSLpyyL6">（2）控制语句。</p><p data-pid="mVZyVuIC">当我们为表示长度可预测的计算开发我们的语言时，我们必须同时包括基本控制结构。事实上，BlooP的特色也恰在于其有限的控制结构集。它不允许你转移到任意的步骤或无限制地循环某一步骤。</p><p data-pid="-1iyLHxx">在BlooP中，基本上唯一的控制结构就是“有界循环”</p><p data-pid="6nTCbgm_">因此重复执行一条命令，他是有一个最大值，这个最大值称之为循环的上界，如果这个上界是300次，那么他最多只能执行循环300次。</p><p data-pid="upFA1VKm">下面说明你怎样才能把这个过程表示在一个BlooP程序之中：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-47e743146b6a6f9eaaeffb68ab5e7a01_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="672" data-rawheight="716" class="origin_image zh-lightbox-thumb" width="672" data-original="https://picx.zhimg.com/v2-47e743146b6a6f9eaaeffb68ab5e7a01_720w.jpg?source=d16d100b"></figure><p><br></p><p><br></p><h2>7、BlooP的约定</h2><p data-pid="fflEcfRC">在上述程序中，定义了一个“过程”，它带有一个“输入参数”N，它的“输出”就是所要得到的值。</p><p data-pid="DVbvPPex">这个过程定义采用所谓“块结构”，这就是说其中某些部分可以被看作一个单元，或“块”。在一块中的所有语句可以被当作一个单元来执行。每一块都有个编号（最外面一层是BLOCK 0），而且用BEGIN和END标记开始和结束。</p><p data-pid="2-LnonjC">上述算法的策略前面已经描述过了。你首先取一个辅助变量，叫CELL(0)，把它的初值赋为1，然后，在一个循环中反复地把其值乘以3，直到这样做完N次为止。下一步，你对CELL(1)做类似处理——把它置成1，反复乘2，做CELL(0)次，然后停止。最后，你把CELL(1)中的值赋给OUTPUT。这个值就是要传回给外部世界的——这是该过程唯一的外部可见行为。</p><p data-pid="8fsQX070">在BlooP中，每个过程在被调用时都能得出一个值——即称为OUTPUT的变量的值。在开始执行任何过程时，OUTPUT都把0值作为其缺席选择值。这样，既使过程根本没给OUTPUT重新赋值，OUTPUT也能始终有一个明确定义的值。</p><p><br></p><h2>8、IF条件语句和分支</h2><p data-pid="YZFAYQjb">现在让我们看另一个过程，它将展示BlooP的其它特点，这些特点使该语言更加具有一般性。如果只会做加法，你怎样才能求出M-N的值呢？窍门在于把各种各样的数和N相加，直至你发现一个与N的和等于M的数为止。</p><p data-pid="BRO4cu6P">而如果是减法会怎么样呢？</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-42f56b0ca7ad643d952649a737e10094_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="477" data-rawheight="574" class="origin_image zh-lightbox-thumb" width="477" data-original="https://picx.zhimg.com/v2-42f56b0ca7ad643d952649a737e10094_720w.jpg?source=d16d100b"></figure><p data-pid="5fyMnfN-">要做减法，需要一个if语句，</p><p><br></p><h2>9、自动组块</h2><p data-pid="KG8Szcdw">下面是BlooP的最后两个需要加以说明的特点，它们都是非常重要的。其一是：一旦一个过程已经被“定义”了，它就可以在后面的过程定义中被“调用”。其效果是一旦某个操作在一个过程中被定义了，它就会被认为和基本步骤一样简单。这样，BlooP就具有了自动组块的特点。</p><p><br></p><h2>10、BlooP测试</h2><p data-pid="CSSH23gb">BlooP的另一个特点是：某些特定过程可以用YES或NO作为其输出，而不是输出一个整数的值。这种过程是“测试”，而非“函数”。</p>