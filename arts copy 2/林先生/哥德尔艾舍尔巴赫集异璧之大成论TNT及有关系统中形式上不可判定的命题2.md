<h2>1、代入导致第二个想法</h2><p data-pid="BpJ2z2Gt">通过上面的讨论，我们已经能够看清TNT是怎样对“是否TNT定理”这一概念进行“反省”的了。</p><p data-pid="7udaHU2v">这就是用到证明对的说法，假设一个陈述可以与n形成一对证明对，就是说“是一条定理”。相反如果他不能形成一对证明对，就是说“不是一条定理”。</p><p data-pid="nhttJHfW">“构成证明对”这一性质可以用Bloop程序测试，因而被一个有两个自由变元的公式在TNT中体现。</p><p data-pid="6l7umYZ2">举个例子，如证明0=0是TNT定理</p><p data-pid="sb3-vvrG">就要证明一个自然数a，他与666,111,666构成TNT证明对。</p><p data-pid="KUwvz710">因为0=666，“=”=111。</p><p data-pid="HH83ifuN">如果说一个自然数a，能够与666，111,666构成证明对。也就是说在TNT系统内，我们可以通过自然数a，导出后面的666,111,666，这就证明了他是形式系统内部的真陈述。</p><p data-pid="gZ14wUEM">这是哥德尔证明第一部分的精华。我们现在打算着手讨论证明的第二个主要想法</p><p data-pid="rJIAtECr">他的方法是，构想一个概念，使我们能够把这种反省集中写入单个句子，要做到这一点，需要把</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-bccf7d3713d7298b002176817f779c45_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="482" data-rawheight="55" class="origin_image zh-lightbox-thumb" width="482" data-original="https://pic1.zhimg.com/v2-bccf7d3713d7298b002176817f779c45_720w.jpg?source=d16d100b"></figure><p data-pid="EXA1zSYJ">比如说，假设现在有a=a，</p><p data-pid="kMzJdwD1">他的哥德尔配数，是262,111,262。</p><p data-pid="VDOy0Oub">下面我们规定a=2，把所有的a，用2替换。</p><p data-pid="4JDejjCK">这样一来，a=a，就变成了2=2。</p><p data-pid="bGwfNv7n">然后，我们再把2=2，用哥德尔配数，得到</p><p data-pid="NSmQAPLq">123，123，666，111,123,123,666。也就是SS0=SS0</p><p data-pid="qL_Y06r-">接着，如果我们要写</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-94fc83e55a07f1a7b26fb042a87b3a77_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="844" data-rawheight="90" class="origin_image zh-lightbox-thumb" width="844" data-original="https://pica.zhimg.com/v2-94fc83e55a07f1a7b26fb042a87b3a77_720w.jpg?source=d16d100b"></figure><p data-pid="o5qs5IwM">总之，他的方法就是，</p><p data-pid="tUPkst5S">（1）原公式的哥德尔数</p><p data-pid="DAIh27k-">（2）其数字表示被插入的那个数以及</p><p data-pid="MYwb0c6R">（3）结果的哥德尔数，这三者之间的关系是原始递归的</p><p data-pid="2IPcev4d">由于这个关系是原始递归的，所以可以用某个有三个自由变元的TNT公式体现。记为：SUB{a',a',a''}。</p><p data-pid="cpmj_5n9">则下面的公式是个TNT定理：</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-cb6c6c5eca497194fec479b15824e790_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="830" data-rawheight="96" class="origin_image zh-lightbox-thumb" width="830" data-original="https://picx.zhimg.com/v2-cb6c6c5eca497194fec479b15824e790_720w.jpg?source=d16d100b"></figure><p data-pid="Hw5IiX-H"> 这里的sub，指的是代入关系，也就是替代或者是同构的关系。</p><p data-pid="xSdxU8WB">如</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-032d987e844e31d2a0696e01b654dd59_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="790" data-rawheight="123" class="origin_image zh-lightbox-thumb" width="790" data-original="https://pica.zhimg.com/v2-032d987e844e31d2a0696e01b654dd59_720w.jpg?source=d16d100b"></figure><p data-pid="FXqQWRQR">第一行是（a+a'）=（SSSS0）</p><p data-pid="LODRZsQQ">然后以2为中心，把它替换为，</p><p data-pid="fM-rPNtk">第三行是（SS0+SS0)=SSSS0</p><p data-pid="Esq-6Qa5">也就是2+2=4</p><p data-pid="Ga9CHbR6">换言之用2替换这里的a</p><p data-pid="Ad9T-IAi">而这个过程依然是原始递归的，我们可以写出一个BlooP测试，使得对任意输入的三个自然数，若它们之间有这关系，该测试就能回答“是”，否则就会回答“否”</p><p><br></p><h2>2、算术<u>㧟</u>摁</h2><p data-pid="lhplXQQ4">到了这一步，我们已经知道了如何说“XX是一条定理”，进而把它哥德尔配数化，甚至把变元都配数。</p><p data-pid="K53GqPDW">现在一个关键点，就是要用到“㧟摁”，这个㧟摁的意思是，把自己带入到他自己之中。</p><p data-pid="VggATzvL">如果我们要构造一个“本TNT符号串不是TNT定理”，这个时候就好像在说“我在说谎”一样。</p><p data-pid="kjehivba">㧟摁显示出了一种出乎意料的价值：它表明了一种制造自指句子的新方法。</p><p data-pid="Q842o2c1">我们举个例子，</p><p data-pid="Kmwb5ZIe">a=S0</p><p data-pid="AXpd3BzX">它的哥德尔数是262,111,123,666。我们将把这个数插进公式自身中——更确切地说是把这个数的数字形式插进去</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-9e3cef8f5499199090b42e2d6dd57d49_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="373" data-rawheight="76" class="content_image" width="373"></figure><p data-pid="WNor-KaC">这个新公式断定了一句笨拙的假理——262,111,123,666=1</p><p data-pid="LA3W5v3G">这样就实现了，将自身的哥德尔配数赋值于自身的自由变元</p><p data-pid="eG_d2WM1">而在TNT内部谈论算数㧟摁，就是使用SUB{a'',a'',a'}</p><p data-pid="-ckMm9zs">可以看到，前两个变元是一样的，这里的数a''，既是原公式的哥德尔配数，又是插进去的数。</p><p data-pid="PZpE7OUm">我们给上述公式造一个缩写记号：</p><p data-pid="SxEmEj19">ARITHMOQUINE{a"，a'}</p><p data-pid="1wD9zmij">意思是，a'是对哥德尔数为a''作算术㧟摁所得公式的哥德尔数</p><p data-pid="cZ_nlQKy">举个例子，</p><p data-pid="_-pxUuva">假设262,111,123,666（即a=S0，即a=1）对他做算数㧟摁化，变成</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-419be4c0ba87cb5f5ed2fb334edc5cf7_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="815" data-rawheight="93" class="origin_image zh-lightbox-thumb" width="815" data-original="https://picx.zhimg.com/v2-419be4c0ba87cb5f5ed2fb334edc5cf7_720w.jpg?source=d16d100b"></figure><p><br></p><p data-pid="8ExCYcdU">这里的123=S，666=0,111=”=“，123=S。</p><p data-pid="xbzQ7ngq">也就是说S0=S，这自然是个假理。</p><p data-pid="xuQejMwx">但是此时，还没有把a=S0插入进去的情况，现在再把这部分插进去，就是把它哥德尔配数以后，变成了262,111,123,666个S</p><p data-pid="EaVUpXAo">也就是说，我们似乎在一句话之中又嵌套了一句话。</p><h2>3、最后一锤</h2><p data-pid="Ou6r7sVq">按蒯恩的方式达到自指的各种方法中，最复杂的一招是㧟摁一个其本身就在谈论㧟摁概念的句子。仅仅㧟摁是不够的——你必须㧟摁一个提及㧟摁的句子！</p><p data-pid="aKTqSUQ5">我们立即来写出那个公式，并称它为G的“服”号串</p><p data-pid="zuxVlH_a">因为</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e004e4170c9a03dd50614dd53ec702f5_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="829" data-rawheight="78" class="origin_image zh-lightbox-thumb" width="829" data-original="https://pic1.zhimg.com/v2-e004e4170c9a03dd50614dd53ec702f5_720w.jpg?source=d16d100b"></figure><p data-pid="tIKIGSCA">翻译为自然语言，就是说</p><blockquote data-pid="3t6naPCE">不存在a,a'，使得{a,a'}构成证明对，且a'是某个a''的算数自摁。</blockquote><p data-pid="yhI_vV-G">再把它通俗一点，就是说不存在a和a'，使得a'（即我们要证的那句话）可以在形式系统内成为定理，并且a'是对哥德尔数为a''作算术㧟摁所得公式的哥德尔数，而这里的数a''，既是原公式的哥德尔配数，又是插进去的数。</p><p data-pid="EXdLYhMQ">我们得到，</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-11894f9944ab86bc11432009bec19715_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="813" data-rawheight="157" class="origin_image zh-lightbox-thumb" width="813" data-original="https://picx.zhimg.com/v2-11894f9944ab86bc11432009bec19715_720w.jpg?source=d16d100b"></figure><p data-pid="70LAMm0O">这里的意思，就是把这里的数a''，换成数字u。</p><p data-pid="DUqs63cj">这样获得的符号串，称之为G。叫做哥德尔符号串。</p><p data-pid="cVq2hwzD">那么该如何理解这个符号串呢？</p><p data-pid="txYdKeGe">我们首先先回答，我们如何造出G来？G的哥德尔数，就是u的算术㧟摁化，因为这个G，来自于</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e004e4170c9a03dd50614dd53ec702f5_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="829" data-rawheight="78" class="origin_image zh-lightbox-thumb" width="829" data-original="https://pic1.zhimg.com/v2-e004e4170c9a03dd50614dd53ec702f5_720w.jpg?source=d16d100b"></figure><p data-pid="F17xU8ij">是对于这个符号串之中的a''进行哥德尔配数以后的结果。</p><p data-pid="KERXtRrB">然后是第二个问题，我们如何理解这个符号串呢？</p><p data-pid="2tjtpWKf">其一、指的是“不存在数a和a'使得（1）：它们形成TNT证明对；并且（2）a'是u的算数自摁化。”</p><p data-pid="6TKt8nvr">其二、u的算数自摁化自然是存在的，故a'是自然存在的。</p><p data-pid="7VXhHtmO">其三、“没有一个数a能与u的算术自摁化成TNT证明对。”</p><p data-pid="rFqixLGM">其四、：“以u的算术自摁化为哥德尔数的那个公式不是TNT定理。”</p><p data-pid="Puyz68UL">其五、以u的算术自摁化为哥德尔数正是G自己。</p><p data-pid="iI69DjHf">其六、G的意思，就是”G不是TNT定理“</p><p data-pid="wjx0k66S">G是不是TNT定理呢？如果是，它说的就一定是一句真理。可实际上G在说什么呢？G就在说它自己的非定理性。于是从它是定理就能得它不是定理——矛盾。</p><p data-pid="-Tu7xnC4">要是G不是定理又如何呢？这倒可以接受，此时不会导出矛盾。不过G的非定理性正是G所断定的——因而G讲的是真理，而G又不是定理，所以就存在（至少）一个不是TNT定理的真理。</p><p data-pid="kVn5S69H">这个东西，就是与说谎者悖论相似的结构，</p><p data-pid="yXEXzORt">其实这个句话就是在说：“我不是一条定理”（我们把它取名为"G"），你没有办法判定是因为</p><p data-pid="p8gzYUQN">1.如果G是定理 则说明它说了一句真话 → 矛盾</p><p data-pid="kzHAr_fK">2,如果G不是定理 那他就的确说了一句真话 → 那他就是不能被系统定理表示的真话——系统不完全性的原因</p><p data-pid="HDsjJSDc">这就是哥德尔不完备定理。</p><p data-pid="WjBHB2Gc">我们上面的工作，无非是把G=我不是一条定理。把它通过形式系统听得懂的话重述一遍。</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-248495c5945345cc24559a72a2dc530f_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="822" data-rawheight="554" class="origin_image zh-lightbox-thumb" width="822" data-original="https://picx.zhimg.com/v2-248495c5945345cc24559a72a2dc530f_720w.jpg?source=d16d100b"></figure><p><br></p><h2>4、哥德尔第二定理</h2><p data-pid="vyf_QoGr">现在知道，若G的解释是真，那么非G就是假。而我们知道TNT系统内是不能推出假的陈述。于是，不论是G还是其否定～G都不会是TNT定理。这样，在我们的系统中就找到了一个“漏洞”——一个不可判定命题。</p><p data-pid="UOzTxwbn">G和～G都不是定理，但公式却是定理，因为命题演算的规则保证全部形如＜P∨～P＞的良构公式都是定理</p><p data-pid="Aw_0kBu9">怎样在TNT内部表示“TNT一致”这句话呢？靠的是这样一个简单事实：不一致性是说有两个公式x和~x——一个是另一个的否定——都是定理。</p><p><br></p><h2>5、TNT是不完全的ω</h2><p data-pid="0GITkSXJ">那么TNT“享有”哪种不完全性呢？我们将要看到，它的不完全性是第八章中定义的那种“欧米伽”型。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-93c7410e5e77c3cd6f415e1d6a0b2def_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="757" data-rawheight="78" class="origin_image zh-lightbox-thumb" width="757" data-original="https://pic1.zhimg.com/v2-93c7410e5e77c3cd6f415e1d6a0b2def_720w.jpg?source=d16d100b"></figure><p data-pid="t0mvFQfe">也就是说，如果每一个定理，都能从他之上的哪个定理推出来，那么这些陈述都是真的。但是对于他的全称断定缺失不能被判定真假的。</p><p><br></p><h2>6、两个不同的补洞方法</h2><p data-pid="ff4C34BG">由于G的解释为真，其否定~G的解释就为假。而利用TNT一致性的假定，我们又知道在TNT中推不出假陈述，于是无论是G还是其否定~G都不是TNT定理。在我们的系统中就找到了一个漏洞——一个不可判定命题。</p><p data-pid="tLRM3u_l">那么对于这个不可判定的陈述意味着什么呢？</p>