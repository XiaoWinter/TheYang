<h2>1、描述的层次</h2><p data-pid="hakuy4-K">哥德尔串G，他具有这样的性质，即他能够在不同层次上被理解。但是这样的事情也不不稀奇，比如说我们的人体由细胞组成，我们所做的一切原则上可以在细胞水平上被描述，但是我们也可能在其它层次上被理解，以至于我们几乎无法把我们关于自身的微观描述与我们的自我感觉联系在一起，以至于我们难以理解，这两者如何是同一个“我”？</p><p data-pid="FgvQlAkY">再比如说我们看电视，我们既可以把电视图像理解为一大串的光点在移动，也可以理解为是有意义的内容</p><p><br></p><h2>2、组块化和棋术</h2><p data-pid="x-Bm14tM">人工智能研究的问题在于，指出如何跨越两种不同的描述层次，即如何构造一个系统，使他在可以在接受一个层次上的描述的同时，生成另一个层次上的描述。</p><p data-pid="cymDGn9F">计算机的下棋与人类下棋有啥不同呢？以及新手下棋和老手下棋有啥不同呢？</p><p data-pid="5m31VK9I">有人加以研究发现，大师们下棋是以组块化去理解棋子的分布的，而新手则是以一个个的棋子来理解棋局的。</p><p data-pid="mCLozyGy">所以如果一个新手和一个老手，面对一部残局，老手能够迅速还原，而新手则不行。</p><p data-pid="H979Iq-l">结论是这样的：在正常的对局过程中，会有某种多次再现的局面——也就是某种模式——而大师正是对这种高层次的模式十分敏感。他和新手在不同的层次上思考，他们的概念集是不同的。</p><p data-pid="bEI2NZLU">他感知棋局的方式象一个过滤器：在观察局势时他实际上看不见坏棋——正象业余棋手在观察局势时看不见不合规则的棋步一样。任何懂一点棋术的人都已经对他的感知进行了组织，斜着走车、象走日字这样的着法不会出现在脑子里。类似地，大师?的棋手在观察棋局时已经建立了更高层次的组织，因此对他们来说，坏棋一般不会被想出来，就象对大多数人来说不合规则的棋不会被想出来一样。</p><p data-pid="pLZQE7GJ">这种区分同样适合于其它智力活动——例如作数学题。一个有才华的数学家往往不象庸才们所做的那样，考虑并尝试所有的错误途径，以达到所需的定理。相反，他一下就“嗅出”了有希望的途径，然后立即进行下去。</p><p data-pid="6btWeQZu">而计算机下棋程序的问题，就在于他只是凭借着蛮力去超前搜索。</p><p><br></p><h2>3、相似的层次</h2><p data-pid="zqjsL8Nr">真正造成混乱的是这样一种情况：同一个系统允许两种以上不同层次的描述，而这些描述在某些方面又是彼此相似的。那时我们会发现，在考虑这种系统时，我们难以避免把层次搞混，很容易完全迷失方向。</p><p data-pid="JNvSckxk">其中最经常出现的情况，就是当我们反思自己的时候，说明我们进行自我认识时的混乱与下述事实有关：我们是由许多层次构成的，同时我们用重叠的语言在所有这些层次上描述我们自己。</p><p><br></p><h2>4、计算机系统</h2><p data-pid="ZyZv6SiM">在另一个层次上也有这样的情况，对同一个系统会出现多层次的描述，这种描述在概念上还彼此相近，这就是计算机程序，在每一层上，描述都是用计算机科学的语言给出的，这使得所有这些描述都多多少少地彼此相似——然而不同的层次上得到的见解仍然极其不同的。在最低层，描述会复杂得就象对电视屏幕上光点的描述一样。但就某些目的而言，这是最重要的视角。在最高层，描述极大程度地组块化，给人一种完全不同的感觉，尽管事实上许多概念都是最低层和最高层所共有的。</p><figure data-size="normal"><img src="https://pica.zhimg.com/v2-6a9e8f33e79c684ca12e204be3150fa0_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="884" data-rawheight="704" class="origin_image zh-lightbox-thumb" width="884" data-original="https://picx.zhimg.com/v2-6a9e8f33e79c684ca12e204be3150fa0_720w.jpg?source=d16d100b"></figure><p data-pid="XgRpEdME">计算机的基本成分有“存储器”、“中央处理器”（CPU）以及一些“输入输出（I/O）设备”。</p><p data-pid="ntf2EH8f">其中首先是存储器，存储器被分为若干称为“字”的物理上分离的单元。为了描述得具体一些，我们假设存储器共有65536个字。一个字可以进一步分为我们当作计算机科学的原子的东西——“位”。</p><p data-pid="ypIhep2h">从物理上看，一个位不过是一种磁性“开关”，它可以处于两种状态。你不妨把这两种状态称为“开”和“关”，或“X”和“O”，或“1”和“0”……第三种是最常用的。存储器中的一个字也可以有不同的功能。当然，有时这36位确实是表示了一个二进制数。另一些时候它们也可能是表示一个电视屏幕上的36个点，或文章中的一个词。存储器中的一个字应当如何理解，这完全取决于这个字在程序中所扮演的角色。</p><p><br></p><h2>5、指令和数据</h2><p data-pid="9kcimXvd">存储器中的字里面不仅可以放被处理的数据，还可以放一些作用于数据之上的程序。有那么一组有限的固定的操作，它们可以被中央处理器——CPU——所执行，而一个字的一部分，通常是前面的几位，可以被解释成要被执行的指令类型的名字。一个解释成指令的字的其余部分代表什么呢？最常见的是，它们说明要对存储器中的哪些字进行作用。换句话说，剩下的位构成了一个指向存储器中其它字的“指计”。</p><p data-pid="XdS8R0Wp">在存储器中，每个字都有各自的位置，象大街上的房子一样。字的位置称为“地址”。存储器里可以有一条“街”或几条“街”——它们被称为“页”。因此，要寻找一个字的地址，必须知道它的页号（如果存储器是分页的）以及它在该页中的位置，所以指令的“指针”部分就是存储器中某个字（或某些字）的地址的数字化表示。</p><p data-pid="4YGdXflj">在任一给定时刻，计算机怎样才能知道该执行什么指令呢？这记录在CPU里。有一个特殊的指针，指向要被解释成指令的下一个字（即存储着它的地址）。CPU把那个字从存储器中提取出来，通过电子手段把它复制到属于CPU自身的一个特殊的字中（CPU中的字通常不叫“字”，而叫“寄存器”）。然后CPU就执行这条指令。这条指令可以要求完成任意一种类型的操作。</p><p data-pid="B7xzdd_2">CPU假定自己应当象个邮递员那样，沿着“大街”走下去，依次把一个个字解释成指令。</p><p><br></p><h2>6、机器语言之别于汇编语言</h2><p data-pid="EnXSjkHy">上面所说的只是“机器语言”的一个粗略框架。在这种语言中，所能执行的操作类型构成了一个不可扩展的有限集合。因此所有的程序，不管多大、多复杂，都必须用这几种类型的指令构成。</p><p data-pid="BrrvGP8S">现在我们要上升到对程序进行描述的层次体系中较高的一层。这就是“汇编语言”层。汇编语言和机器语言之间差别并不大，事实上，这一改变很平缓。在汇编语言的指令和机器语言的指令之间实质上存在着一一对应。汇编语言的设计思想是要把各个机器语言的指令“组块化”，因此当你要用一条指令把一个数加到另一个数之上时，不必再写一个若干位组成的串“010111000”，而只写ADD（加）就行，然后也不必以二进制表示的形式给出地址，而是用一个“名字”指示存储器中的字。因此，用汇编语言写的程序很象用机器语言写的程序，只是容易被人读懂了。</p><p data-pid="VIxfC6cc">回到关于DNA的想象上来，我们可以把机器语言和汇编语言之间的差别比作下面两种方法间的差别：一种是麻烦地一个原子一个原子地说明每个核苷酸，另一种是在说明一个核苷酸时仅仅给出它的名字（即“A”、“G”、“C”或“T”）。通过这种非常简单的“组块化”操作可以节约大量的劳动，虽然观念上并没有很大的改变。</p><p><br></p><h2>7、翻译程序的程序</h2><p data-pid="752WgAnF">汇编语言的主要意义不在于它与机器语言间并不显著的差别，而是这样一个关键的想法：程序完全可以在不同的层次上编制！硬件是被设计来“理解”机器语言写出的程序——即位序列——而不是面向字母和十进制数字的。</p><p data-pid="HbE78Zia">人们可以用机器语言写一个“翻译程序”。这个程序叫“汇编程序”，它可以接受易记的指令名、十进制数字及其它容易被程序员记住的方便的缩写，然后把它们转换成单调然而严格的位序列。用汇编语言书写的程序在被“汇编”（即翻译）之后，就可以“运行”了——或者说它的机器语言等价物可以运行了。</p><p data-pid="O7swJyot">但这只是个说法问题。哪个层次的程序在运行？如果你说是机器语言写出的程序运行，那是绝不会错的，因为任何程序的运行都必须通过硬件——但根据汇编语言来考虑运行中的程序同样是很合理的。</p><p><br></p><h2>8、更高级的语言、编译程序和解释程序</h2><p data-pid="g7BQyQZK">人们在编程序的时候发现有一些有特点的结构会反复出现，正象下棋一样，似乎存在某些基本的“定势”，它们会自然地出现在人们想要构造“算法”的时候——所谓“算法”是指人们对所要完成的操作过程的精确描述</p><p data-pid="hBBaY6W0">在典型情况下，一个算法的高层成分不只包含一两条机器语言指令，而是包含整整一组，并且这些指令在存储器中也不一定是相邻的。这样的一个成分可以在一个更高层的语言中用单个的项来表示——这就是一个组块</p><p data-pid="4JNZndqY">除去标准组块——即新发现的那些可以构成所有算法的成分——之外，人们还认识到几乎所有的程序都包括有更大的组块——或者叫超组块。不同的程序有不同的超组块，这取决于程序要完成哪些高层次的任务。我们在第五章里已经讨论过超组块，用的是它们通常的称呼：“子程序”和“过程”。</p><p data-pid="3X1vrR-c">显而易见，对任何程序设计语言的一个强有力的扩充就是赋予它们下迷能力：用已知的实体定义新的高层实体，然后用名字调用它们。这就把形成组块的运算直接建立在语言之中了。这样，就不再有一组固定的指令，要求所有的程序都直接用这组指令来编制，而是使程序员能构造自己的模块，每个模块都有自己的名字，而且可被用在程序内的任何地方，就象它们本来就是这种语言的成分一样。</p><p data-pid="Jm4sw24S">基于这种想法的新语言被称为“编译语言”。</p><p data-pid="xjItT5up">简单来说，编译语言符合人的感知，但是不符合计算机，必须通过某种方式把他转化为汇编语言，再把他转化为机器语言。而汇编语言介于编译语言和机器语言之间，他也不能直接被计算机所使用。而机器语言是可以直接运行，但是他不符合人类的感知。</p><p data-pid="iNH_CSVO">解释程序”也被发明出来了。象编译程序一样，解释程序也能把高级语言翻译成机器语言，但不是先把全部语句翻译完，然后执行机器代码，而是读一行然后立即执行它。</p><p data-pid="3AW9c4Y6">因此，一个解释程序和一个编译程序相比，就象一个同声翻译和一个书面发言翻译相比一样。</p><p></p>