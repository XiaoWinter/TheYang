<h2>1、什么是递归？</h2><p data-pid="L9umXHlL">什么是递归呢？递归就是自我调动，他的表达就是嵌套，比如说俄罗斯套娃，一层套一层，出现自我的不断地调用。有时候，递归与悖论很接近，比如说递归定义，这样的定义会给人一种事物自己定义自己的感觉，似乎会导致无穷回归。但是事实上，递归定义不会导致无穷回归，因为递归定义，并不是以事物自身来定义事物本身。</p><p data-pid="vesI0jj1">我们举个例子，假设有个秘书接电话，首先是A打进来，然后秘书跟他说话。但是没过多久，B也打进来，于是他对A说，让他等等。于是转接到B，但是同时C又打进来，于是他又转接到C，这个过程我们可以设想无限进行下去。然后假设与C的对话结束，他又调回去与B说话，接着调回去与A说话。假设此时D又打进来，那么D优先得到照顾。等D结束后，又调到B，再调动A。</p><p><br></p><p><br></p><h2>2、推入、弹出、堆栈</h2><p data-pid="U7s0ECxb">前面那个例子说的就是，推入，弹出和堆栈等术语。</p><p data-pid="uOXCyVoC">堆入就是暂时手头的工作，记住在哪里停下来，并且开始新的工作。这个新的工作，往往被视为比前一个工作低一个层次。而弹出则是结束这个层次的操作，跑到刚刚暂停的工作继续干活。</p><p data-pid="59Av2vI6">那么，我们怎么知道，当时在哪里停住呢？这就需要有一个信息，所以需要把相关信息都堆积在堆栈之中。这些信息要包括</p><p data-pid="-iR6U2Tq">1、在未完成的工作，是在哪个节点被打断的，这被称之为返回地址</p><p data-pid="4p8zcS8w">2、在打断处，你原来要干什么，这叫做变量约束。当你弹回去恢复某个工作，堆栈保存着你的环境，这被称之为现场。</p><p data-pid="ZSvJcTW-">以上述打电话为例子，堆栈就需要知道，不同层次谁在等候，以及你们的谈话已经进行到哪里了？</p><p data-pid="WSUgWrFM">再举个例子，我们听新闻的时候，常常会有，主播说：现在把时间交到某某外派记者。然后这个记者就报道外国的事情，并且把相关的录像拿出来佐证。</p><p data-pid="NaCcu9R9">所以我们可以看到，主播是第一个层次，记者是第二个层次，录像是第三个层次，三个层次依次降低。</p><p><br></p><h2>3、音乐中的堆栈</h2><p data-pid="6ShbP1VQ">音乐之中也有堆栈，毫无疑问，音乐都是具有层次性的，而具有层次，就意味着它具有推栈。每一个新的变调都把一个新的调子推上堆栈。进一步说，这就象是我们想听到调子以相反的顺序，从堆?中一个一个地弹出，直到还原到主调音。</p><p><br></p><h2>4、递归迁移网</h2><p data-pid="GNPQNkYq">我们的语言结构也具有堆栈性，所有语言的语法结构都涉及建立一个非常精细的下推栈。句子的句法结构提供了一个好场所。描述他的一个方式，叫做递归迁移网（RTN）。</p><p data-pid="K53sYcpj">RTN表示出为完成一个特殊任务可以遵循的各种通道，然后通道之中有很多节点，由小方格表示，然后他们由带着箭头的弧线联系起来，</p><figure data-size="normal"><img src="https://pica.zhimg.com/v2-a28444cadd7dbe75d7cccbfd7dc97334_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="731" data-rawheight="390" class="origin_image zh-lightbox-thumb" width="731" data-original="https://picx.zhimg.com/v2-a28444cadd7dbe75d7cccbfd7dc97334_720w.jpg?source=d16d100b"></figure><p data-pid="JL-ZylTH">这就是一个例子。a表达的是花哨名词，他告诉我们如何造出某种类型的名词词语，首先我们要找出一个指示代词，接着造出量词，接着造出形容词，再造出个名词，比如说那个胖山谷。但是弧线又意味着还有其他可能，比如说直接造出名词。</p><p data-pid="0ws-6iox">而碰到名词，会暂时地让一个过程进入控制，这个过程目的在于从名词库中取出一个名词，从而产生名词，这个过程叫做“过程调用”，接着再把控制权交给你。所以在这里有四个过程调用，分别是造出指示代词、量词、形容词和名词。</p><p data-pid="3d_MH4rZ">而花哨名词还可以被豪华名词作为一个东西吧被调用。</p><p data-pid="OKmc7YKQ">而当我们进入到b，豪华名词的时候，就出现了递归现象。因为在这里似乎出现了循环。</p><p data-pid="3P17Bs0S">每一个可行的通道，最终都要调用花哨名词，这导致，不可能避免地必须得到这样的一个名词。并且有可能不再带任何非花哨名词所提供的修饰语。并且他包含着对于豪华名词自身的调用，仿佛是自己调用自己。</p><p data-pid="lUq6cO3b">比如说，某个顺序是，及物动词、豪华名词、的、花哨名词。</p><p data-pid="_J5CRguh">首先先给出一个及物动词（如结交），接着给出豪华名词。但是我们不是正处于豪华名词吗？比如说那个接电话的人，他也是在通话中间接到另一个电话，他所做的只不过把前一个电话储存在堆栈之中。</p><p data-pid="Q5v-MaJH">所以我们也效法这种模式，我们需要在堆栈中写下我们在外层调用豪华名词所在的节点，然后就好像没有任何不寻常之处，我们就弹回到了豪华名词的开始处，接着我们选择下面那条道路，即介词、豪华名词、的、花哨名词。</p><p data-pid="rEuFUChb">这个时候，当我们调用介词（如朝向）后，又会遇到豪华名词，又遇到了递归，于是我们停下来，再下降一个层次，然后弹回到开始，直接以中间那个通道，形成花哨名词，假如得到的是“逻辑”（这就是豪华名词）。这样这个节点就结束了。</p><p data-pid="lKhjvB3r">接着弹回到原来的堆栈（介词这个通道），这样我们就获得了朝向逻辑，接着出现“的”，然后调用花哨名词，比如说鼻子，这样这个通道也就结束，弹出，其结果是“结交朝向逻辑的鼻子”。</p><p data-pid="AMSZsOmb">接着最上层那个，首先是豪华名词（逻辑），及物动词（结交）、的、花哨名词（假如是努力），这样这里也就结束。</p><p data-pid="FK0hu4sW">最终结果就是“结交朝向逻辑的鼻子的努力”</p><p data-pid="qIa5_Ani">我们并没有陷入无穷回归。因为在RTN豪华名词里至少有一条通道不涉及任何对豪华名词本身的递归调用。</p><p><br></p><p><br></p><h2>5、终了”和异层结构</h2><p data-pid="tU2gAk32">那么，递归定义和循环定义的区别在于，递归定义会终了，换言之总有一条道，是避免自指的。因而构造一个满足该定义的对象最终总会终了。如果他不终了会怎么样呢？结果就是栈会溢出而崩溃了。</p><p data-pid="C_WcVLZe">如果他们互相调用，互相缠绕，发疯一般地互相调用或调用自己。程序的这种结构，即没有单独的“最高层次”或“控制器”，称作“异层结构”</p><p data-pid="ay8GxTJm">还可以举个例子，</p><p data-pid="q7hpQY0x">假设我们定义一个函数f（x）=x+f（x-1）</p><p data-pid="yYRhO_eA">我们会发现，在f（x）之中，f（x-1）又调用了f（x）</p><p data-pid="Dj6Yhvcj">假设我们要求f（3），他等于多少呢？</p><p data-pid="aCQVbw1m">f（3）=3+f（3-1）=3+f（2）</p><p data-pid="9XYw5Rq3">那f（2）=？</p><p data-pid="flleHj18">f（2）=2+f（1）</p><p data-pid="iTfhO_RW">f（1）=？</p><p data-pid="HZ0Zh_7J">f（1）=1+f（0）</p><p data-pid="0TVCC7db">f（0）=？</p><p data-pid="ur6sUn-G">f（0）=0+f（-1）</p><p data-pid="mcXwEvL4">..........</p><p data-pid="830peLLb">于是系统就崩溃了。这就是不能终止，而递归则必须能够把他终止下来。</p><p></p><p></p><p></p><p></p>