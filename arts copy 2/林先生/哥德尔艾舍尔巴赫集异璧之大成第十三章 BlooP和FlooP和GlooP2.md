<h2>1、BlooP程序包含了过程组成的链</h2><p data-pid="vFlaWT6H">我们已经看到了在BlooP中怎样定义过程，但过程定义只是一个程序的一部分。一个“程序”包括一条“过程定义链”（其中每个过程仅仅调用前面定义的过程），还可能跟着一个或多个对所定义过程的“调用”。</p><p data-pid="MibEUJq6">如果你只有一条过程定义链，那什么东西都不会被执行。它们就在那里等着调用，等着用特定的数值启动它们。这就象一台绞肉机等着肉来绞——或者说更象一串连在一起的绞肉机，前面一台绞完了就送进后一台……对于绞肉机来说，这种安排可能没什么必要，但对于BlooP程序来说，这种结构是非常重要的。我们可以可以称它为一个“待调用程序”。</p><figure data-size="normal"><img src="https://pica.zhimg.com/v2-be6426a9781e45d366014516c19863bb_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="323" data-rawheight="649" class="content_image" width="323"></figure><p><br></p><p data-pid="-SVtCB-m">现在BlooP是我们用来定义可预知终止的计算的语言。可以用BlooP来计算的函数的标准名称是“原始递归函数”；而可以用BlooP测试来验证的性质的标准名称是“原始递归谓词”。</p><p><br></p><h2>2、可表示性和可体现性</h2><p data-pid="BCVF7SOl">我们有必要回顾一下引入Bloop的原因。</p><p data-pid="x1kenlqs">我们首先需要区分两个概念，一个是叫做可表示性，一个叫做可体现性。表示一个谓词，就是从自然语言到严格的形式化的翻译过程，这与所翻译的是不是一个定理没有关系。而可体现性，则是要求</p><p data-pid="m8R-eSo0">1、谓词的全部为真的“例”都是定理</p><p data-pid="my5Lh5oq">2、全部为假的“例”均为非定理。</p><p data-pid="D_kDUzCe">“例”指的是用数值取代谓词中的所有自由变量得到的串。这样他在形式系统内是可以被判定的。</p><p data-pid="oZbCU2qg">而TNT这个形式系统的优点在于，能够表示数论之中的任何谓词。</p><p data-pid="a_HK-49B">因此问TNT作为一个公理系统有多强，就是问在TNT之中哪些性质是可体现的。</p><p data-pid="gPI5l_ns">是不是所有可能的性质在TNT中都是可体现的？若是如此，那么TNT就能回答数论中的任何问题，它就是完全的。</p><p><br></p><h2>3、原始递归谓词在TNT中是可体现的</h2><p data-pid="h1-beMJo">如果数论中的某个陈述的真假能够用计算机，在一个可预知的长度的时间内加以判定，那么他在TNT中也是可以判定的。即如果能为自然数的某个性质写出一个BlooP测试，那么这个性质在TNT中是可体现的。</p><p data-pid="YUvUrZSH">此处的“原始递归”指的是，他总是能够得到判定。</p><p><br></p><p><br></p><h2>4、存在非原始递归的函数吗</h2><p data-pid="X38wVWOh">通过BlooP测试可以测试很多不同的性质，包括一个数是否为素数或完全数、是否具有哥德巴赫性质、是否是2的幂，如此等等。这自然地会使人考虑是不是数的每种性质都能被某个适当的BlooP程序所检查。</p><p data-pid="TyAOvV8f">因此，这个问题实质上是“是否总能给出运算长度的上界——还是说在自然数系统中存在一种内在的混乱，致使有时无法事先预测运算的长度？</p><p><br></p><h2>5、B库、索引编号和蓝程序</h2><p data-pid="Ndd0wMPZ">让我们首先设想一个新奇的概念：装着所有可能的BlooP程序的库。不用说，这个库——“B库”是个无穷大的库。然后我们对此进行三个连续的过滤操作。</p><p data-pid="7jaVigtD">第一个过滤器，为我们选出待调用的程序。第二个过滤器，去掉这个子库中的全部“测试”，只留下“函数”。</p><p data-pid="j5qymli6">第三个过滤器选出那些恰有一个输入参数的函数。</p><p data-pid="p3nSQwrD">剩下来的是一个包含所有这样的待调用BlooP程序的完整库：这些程序计算那些恰有一个输入参数的函数。</p><p data-pid="LrOt3qQk">让我们称这些特殊的BlooP程序为“蓝程序”</p><p data-pid="A0cbJdP3">现在我们要做的事是为每个蓝程序指定一个互不混淆的“索引编号”。怎样做呢？最简单的办法——我们正是要这样做——就是根据长度把它们排列起来：可能的蓝程序中最短的为1号，次短的为2号，等等。当然，会有许多长度相同的程序。为解决这个问题，我们使用字典次序。在这里，“字典次序”是在拓广的意义下使用的，其中字母表里包括BlooP中的所有附加字符，以某一次序排列起来</p><p data-pid="wGQaGZeM">如</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-20ac579dfd170f54ad2a381cdd179316_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="288" data-rawheight="158" class="content_image" width="288"></figure><p data-pid="A05NkXjb">我们可以把所有长度为1的蓝程序放在第一列，两个字符组成的程序放在第2列，等等。</p><p data-pid="hzh5tbad">如我们给出一个程序，</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-24621f9965ea214823686cf2516111ff_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="554" data-rawheight="130" class="origin_image zh-lightbox-thumb" width="554" data-original="https://pica.zhimg.com/v2-24621f9965ea214823686cf2516111ff_720w.jpg?source=d16d100b"></figure><p data-pid="rTKhyIr1">此时输入0，结果还是0.</p><p data-pid="NlWV2uIR">我们此时关注的是，如果存在着一个目录表，那么他应该是良定义的，即每个蓝程序能从中得到一个唯一确定的索引编号。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-9a0fc0ce19598e8680123477ee4e0894_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="876" data-rawheight="330" class="origin_image zh-lightbox-thumb" width="876" data-original="https://picx.zhimg.com/v2-9a0fc0ce19598e8680123477ee4e0894_720w.jpg?source=d16d100b"></figure><p><br></p><h2>6、对角线法</h2><p data-pid="2gYLqV6T">我们将用这个蓝程序的目录表定义一个单变量函数——“蓝对角”[N]——而且将会发现这个函数根本不在表中（这就是把它的名字加上引号的原因）。而“蓝对角”很显然是个良定义的单变量可计算函数，这样我们就不得不下结论说，存在一些不能在BlooP中编程序的函数。</p><figure data-size="normal"><img src="https://pica.zhimg.com/v2-419005f24c8c02d880169f98491f11f8_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="586" data-rawheight="84" class="origin_image zh-lightbox-thumb" width="586" data-original="https://picx.zhimg.com/v2-419005f24c8c02d880169f98491f11f8_720w.jpg?source=d16d100b"></figure><p data-pid="RCaOujgA">我们的策略是：把每台“绞肉机”的索引编号送给它自己去加工，然后把它的输出值加1。</p><p data-pid="Izt3nsd0">比如说，假设编号是12，那么N=12，代入进去，蓝程序就是函数2N=2X12。然后再加1</p><p data-pid="WftOKpRu">“蓝对角”的独特之处在于：它不出现在全部蓝程序所构成的目录表中。它不可能在那里。</p><p data-pid="nlYJAbiV">因为如果他存在，那么他就是一个蓝程序，而如果他是一个蓝程序，那么他就有一个索引编号，</p><p data-pid="Hp8GmJN-">即</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-c723e265bdd11ebeba66fa44e9cc0beb_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="556" data-rawheight="49" class="origin_image zh-lightbox-thumb" width="556" data-original="https://pic1.zhimg.com/v2-c723e265bdd11ebeba66fa44e9cc0beb_720w.jpg?source=d16d100b"></figure><p data-pid="LXgNOaBF">等式1和等式2是互不相容的。因为等式1要加1.</p><p data-pid="KIKTL6cz">如果要让他们相等，就是说</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e26ac95e10cf7886d18e93aee2966e14_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="584" data-rawheight="126" class="origin_image zh-lightbox-thumb" width="584" data-original="https://picx.zhimg.com/v2-e26ac95e10cf7886d18e93aee2966e14_720w.jpg?source=d16d100b"></figure><p data-pid="DTxTDKN2">而这样一来，实际上就是不可能的。</p><p data-pid="JV-4gCxq">唯一可能的选择是丢掉公式（2）所表示的假设：函数“蓝对角”[N]可以写成一个蓝BlooP程序。而这就证明了“蓝对角处于原始递归函数的范围之外”。这样，我们就达到了目的，一举摧毁了阿基里斯所珍爱的那个朴素观念：每个数论中的函数都必定能在可预测的步数内被算出来。</p><p data-pid="7VjANajE">这里出现了一些很微妙的事情。比如说你可能会考虑这个问题：对每个特定的N值来说，在计算“蓝对角”[N]时所包括的步数总是可预测的——但这些不同的预测方式不能全都结合成一个普适的方法，以预测“蓝对角”[N]的运算长度。</p><p></p>