<blockquote data-pid="__Jy0ZBa">5．2命题的结构之间具有内在的关系。<br>5．21 为了在我们的表达方式中突出这些内在关系，可以把一个命题表现为一个运算的结果，这个运算通过另外一些命题（即该运算的基础）而产生出这个命题来。<br>5．22运算就是其结果和基础两者结构之间关系的表达式。<br>5．23必须对一个命题施以运算才能产生出别的命题来。<br>5．231当然，这要依赖于它们形式的属性，依赖于它们形式的内在相似性。<br>5．232整编成一个系列所依赖的内在关系，等价于一个从一项产生出另一项来的运算。<br>5．233运算只能出现在一个命题以逻辑上有意义的方式产生于其它命题的地方，也即命题的逻辑构造开始的地方。<br>5．234基本命题的真值函项是以基本命题为基础的运算的结果（我称这些运算为真值运算。）<br>5．2341 p的其值函项的意义是 p的意义的真值函项。<br>否定、逻辑加、逻辑乘等等都是运算。<br>（否定将命题的意义反转。）</blockquote><p data-pid="f8_pIez7">在维特根斯坦看来，形式是决定结构，如果说命题的一般形式表明了命题的本质，也就决定了命题的内在性质和内在关系，因此他表现为命题结构的内在性质和内在关系。</p><p data-pid="MxkMTcxH">那么，这个命题结构的内在关系如何表现出来呢？他表现为什么呢？在维特根斯坦看来，这就是运算。</p><blockquote data-pid="xoY0537h">可以把一个命题表现为一个运算的结果，这个运算通过另外一些命题（即该运算的基础）而产生出这个命题来。</blockquote><p data-pid="51WFIZsi">即是说，基本命题是命题的真值主目（即自变量），我们可以把命题看成是基本命题的一种运算。</p><blockquote data-pid="VafLrUne">5．234基本命题的真值函项是以基本命题为基础的运算的结果（我称这些运算为真值运算。）<br>5命题是基本命题的真值函项。<br>（基本命题是自身的真值函项。）</blockquote><p data-pid="fQsq0hJC">由此可知，命题是基本命题运算的结果，而基本命题构造命题，就需要通过运算才能达成。那么什么是运算呢？</p><blockquote data-pid="1OVY-Qvu">5．22运算就是其结果和基础两者结构之间关系的表达式。<br>5．23必须对一个命题施以运算才能产生出别的命题来。</blockquote><p data-pid="ekp7UHFW">运算，仅仅只能从一个基础得到结果，它本身并不能表达含义，但是也只有通过运算，才能产生别的命题，这也就说明了，语言的扩展性是如何可能的</p><p data-pid="RYG7dRW-">我们举个例子来加以说明</p><figure data-size="normal"><img src="https://picx.zhimg.com/v2-56b9ddbd63ba774572f474e411b994da_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="491" data-rawheight="551" class="origin_image zh-lightbox-thumb" width="491" data-original="https://picx.zhimg.com/v2-56b9ddbd63ba774572f474e411b994da_720w.jpg?source=d16d100b"></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-c610c10c5729ad7e997588827824f2c6_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="494" data-rawheight="349" class="origin_image zh-lightbox-thumb" width="494" data-original="https://pic1.zhimg.com/v2-c610c10c5729ad7e997588827824f2c6_720w.jpg?source=d16d100b"></figure><p data-pid="mwk4TS_M">我们用N（p）代表否定p，用N（p，q）来表示否定p且否定q。用N（p，q，r）来表示，否定p且否定q且否定r。那么其真值情况就如图所示</p><p data-pid="XV0eBZbc">如图所示可以知道，N（p），其真值表达式就是（假，真）。而N（p，q）则是（假假假，真）。</p><p data-pid="_5SYBqzM">由此可见，我们对于p进行赋值，我们就可以算出他的否定式的真值。这个否定，就是一种运算，而且是最简单的运算。因此他说</p><blockquote data-pid="DTQ33-C7">5．2341 p的其值函项的意义是 p的意义的真值函项。<br>否定、逻辑加、逻辑乘等等都是运算。<br>（否定将命题的意义反转。）</blockquote><p data-pid="d5eHy5-y">否定，就好像是加减乘除的符号，来表达运算。</p><p data-pid="BBoRn0_n">在这里，我们仿佛看到，运算和函项有着密切的关系，那么两者有什么区别呢？</p><blockquote data-pid="tKerxrGz">5．24运算显示于变项中，它显示我们怎样可以从命题的一种形式得到另一种形式。<br>运算表达形式之间的差异。<br>（运算的基础与其结果之间所共有的恰为这些基础本身。）<br>5．241运算标志的不是一种报式，而是一种形式之间的差异。<br>5．242 从“p”产生“q”的运算，同样也从“q”产生“r”，如此等等。表达这一点的唯一方式是：“p”、“q”、“r”等等必须是为一定的形式关系给出一般表达式的变项。<br>5．25运算的出现并不表征命题的意义。<br>的确，运算是无所陈述的，只有它的结果才有所陈述，而这又依赖于运算的基础。<br>（运算和函项决不能在相混淆。）<br>5．251一个函项不可能是它自身的主目，然而一个运算的结果可以成为该运算自身的基础。<br>5．252只有这样，从一个形式系列中的一项到另一项（在罗素和怀特海的等级系统中是从一个类型到另一个类型）的推移才是可能的。（罗素和怀特海不承认这种推移的可能性，但是他们自己却一再地利用这种可能性。）<br>5．2521一个运算重复地应用于其自身的结果，我称之为运算的<br>连续应用（“o’o’o’a”是三次连续应用运算“o’ξ”于“a”的结果。）<br>我也在同样的意义上谈到连续应用几个运算于若干个命题。<br>5．2522因此我把形式系列a，o’a，o’o’a，……的通项记为“[a，x，o’x]”。<br>这个括起来的表达式是一个变项：其中第一项是形式系列的首项，第二项是系列中任意选取的项x的形式，第三项是系列中紧接 x之后的那一项的形式。<br>5．2523连续应用一个运算的概念和“如此等等”这个概念是等价的。<br>5．253一个运算可以取消另一个运算的作用，运算可以互相抵销。<br>5．254运算可以消失（如在“～～p”中的否定：～～p＝p）。</blockquote><p data-pid="owFXJHba">运算和函项的区别在于，</p><p data-pid="anFsRlho">其一、运算只能表达为变项，不能表达某种含义。运算所断言的仅仅是从一个运算基础得到一个结果，他本身并不构成命题的一部分。</p><blockquote data-pid="yW5WvjX5">5．25运算的出现并不表征命题的意义。<br>的确，运算是无所陈述的，<b>只有它的结果才有所陈述</b>，而这又依赖于运算的基础。<br>（运算和函项决不能在相混淆。）</blockquote><p data-pid="V_EW1zn8">其二、命题的真值函项只不过是运算的结果，他本身不是运算。运算是独立于命题之外的一种操作。</p><p data-pid="UeKsV339">其三、运算不是命题形式的一部分，仅仅标记出形式的差别，而不构成形式或结构，运算并不就是这个差别，而是产生这个差别的操作</p><p data-pid="Ex8xdfb6">其四、我们可以用函项来标记运算的结果，但是他毕竟不是运算，写下来的记号仅仅表明已经完成的运算。所以，函项的值不能是函项的主目（如，y=f（x），其中x和y不可混淆。y不是x）。尽管我们可以把y的值，再进行运算。</p><blockquote data-pid="BK-0y3NA">5．251一个函项不可能是它自身的主目，然而一个运算的结果可以成为该运算自身的基础。</blockquote><p data-pid="i1C27iXe">例如说，一个函项f(x)的值不能是这个函项的主目，我们不能用这样的形式“f(f(x))”来表明这一点，它所表示的仅仅是对函项f(x)的值再取函项，由此得到新的值，但这个值不是函项f(x)的主目。因此，一个函项不可能是它自己的主目。一个运算的结果却能够是它自己的基础，这就是重复运算的情况</p><p data-pid="fdJh--nW">运算是一种由运算基础得到运算结果的过程，给定了运算基础和运算，就确定了运算结果。而一个命题的真值函项则是表达某种含义，我们可以通过对于真值函项的限制来达成对其含义的限制，这就是类型论的起点。</p><p data-pid="scKccYwY">其五、维特根斯坦认为，与运算对应只能是一个形式序列。例如说“p，q，r...”一个序列。其含义在于</p><blockquote data-pid="JWMD4GDh">5．242 从“p”产生“q”的运算，同样也从“q”产生“r”，如此等等。表达这一点的唯一方式是：“p”、“q”、“r”等等必须是为一定的形式关系给出一般表达式的变项。</blockquote><p data-pid="GvPEgVg2">即我们从重复运算或迭代运算，在这里就给出了一个序列。</p><p data-pid="N3NvwYoH">要实现这一点，就需要找到构成构成表述一个形式序列中的运算的所有命题共有的东西，即为一定的形式关系给出一般表达式的变项</p><p data-pid="NaGwAvHT">维特根斯坦在这里说，把运算理解成形式序列，就可以借以完成从系列中的一项到另一项推移，但罗素和怀特海的系统却不允许这样的推移（即使它实际上运用了这种推移）。</p><p><br></p><blockquote data-pid="FnILocbS">5．3所有命题都是基本命题的真值运算结果。<br>真值运算是从基本命题产生出真值函项的方法。<br>依据真值运算的本性，就如从基本命题产生出它们的真值函项一样，以同样的方法也可以从真值函项产生出新的真值函项。当一个真值运算施用于基本命题的真值函项，总是产生出基本命题的另一个真值函项，即另一个命题。对基本命题真值运算的结果再作一次真值运算，其结果总可等同于对基本命题施用某一单独的真值运算。<br>每个命题都是对基本命题作真值运算的结果。<br>5．31即使“p”、“q”、“r”等等不是基本命题，<br>4．31的图式也是有指谓的。<br>容易看出，即使“p”和“q”是基本命题的真值函项，<br>4．442中的命题记号也仍然是表达基本命题的一个真值函项。<br>5．32所有真值函项都是把有限数量的真值运算连续应用于基本命题的结果。</blockquote><p data-pid="rfxlzFfH">所有命题都是基本命题运算的结果，但是不是运算本身。运算只不过是一种操作或方法。</p><p data-pid="v5zyD9uy">总之，可知，命题是基本命题的真值函项，就可以得到命题是对基本命题作真值运算的结果这一结论。由于运算可以重复进行，我们可以对由基本命题得到的运算结果进行再次运算，如此可以继续重复下去。</p><p data-pid="oN4AJxcG">这样一来，无论什么样的命题，只要出现在真值运算的形式序列中，最终都可以表明是基本命题的真值运算结果。这样就达到了这样一个结果：赋予命题以意义的东西（基本命题）最终也赋予命题以真值可能性。运算在结构上表明了这种真值可能性是什么。当我们把运算表示成真值函项时，就显示了命题的真值可能性。</p><p data-pid="Tb68sn_I">显然，这就解决了本书的两大问题</p><p data-pid="lv-7ugOO">其一、命题的意义如何可能？他是通过基本命题确保，而基本命题的确保，取决于命题的逻辑形式</p><p data-pid="lDKHEqkX">其二、语言如何从有限规则构造出无限的语句？就是通过运算完成的。</p><p><br></p><blockquote data-pid="e75xqg23">5．4这就表明，没有（在弗雷格和罗素的意义上的）“逻辑对象”或“逻辑常项”。<br>5．41 因为：所有的对于真值函项的真值运算结果，只要它们是基本命题的同一个真值函项，就都是等同的。<br>5．42显然，V、?等等不是右和左等等那种意义上的关系。<br>弗雷格和罗素的逻辑“初始记号”的交叉定义已足以表明，它们不是初始记号，更不是关系的记号。<br>显然，通过“～”和“V”定义的“?”和在“V”的定义中与“～”一起出现的<br>那个“?”是等同的；而且后面这个“V”与前一个“V”也是等同的，如此等等。<br>5．43从一个事实 p会得出无数其它事实，即～～p，～～～～p等等，这看起来有点令人难以置信。同样使人惊讶的是，无数的逻辑（数学）命题是从半打“初始命题”得出来的。 但是一切逻辑命题之所说都是相同的，即什么也没有说。<br>5．44真值函项不是实质函项。<br>例如，肯定可以由双否定产生，团此否定是否在某种意义上就包含在肯定之中呢？<br>“～～p”是否定～p，还是肯定 p，还是两者都是呢？<br>命题“～～p”并不是把否定作为一个对象而与之相关；而另一方面，否定的可能性在肯定中又是早就预定了的。<br>而且，如果存在一个称为“～”的对象，那么就会得出，“～～p”说了某种不同于“p”所说的东西。这是因为一个命题涉及“～”，而另一个命题则否。<br>5．441这些表面的逻辑常项的这种消失，也发现于“～（?x）·～fx”的情形，它与“（x）·fx”的所说是一样的；或者也发生于“（?x）·fx·x＝a”的情形，它与“fa”说的是一回事情。<br>5．442如果给定一个命题，那么以它为基础的一切其值运算的给果也随之给定。</blockquote><p data-pid="wK0QOkXc">5.4一开始，就可以否定罗素和弗雷格的逻辑对象或逻辑常项。</p><p data-pid="nrh-9L41">那么他否定了什么呢？我们来看罗素和弗雷格的工作，</p><p data-pid="L7ibeuDN">他们都试图建立起一个逻辑体系，他是用来刻画命题结构的框架，他有两个目的</p><p data-pid="JW3zLSve">其一、使用逻辑符号来描述命题的结构和关系</p><p data-pid="eT02YKtf">其二、要建立起公理体系，用这个体系来证明形成和转换规则的可靠性。</p><p data-pid="7KCTKDh0">那么针对第一个目的，他们往往需要两步</p><p data-pid="Y65a1pUT">1、定义一些命题结构的记号</p><p data-pid="eJh4YIIz">2、通过这些记号之间的转化规则，来说明命题结构之间的关系</p><p data-pid="oTnaY6FF">那么，在弗雷格和罗素看来，命题之间的关系就是一种结构关系。命题就好似是我们通过某种结构组织起一些词项，命题结构构成了词项的基础。</p><p data-pid="5z6DFe21">而维特根斯坦认为，并不是结构决定了命题记号形成什么命题，而是命题形式。而命题形式却只能在不同的命题结构的内在关系之中起作用。</p><p data-pid="eN8ukC_u">由于有这两个的区别，那么对于逻辑常项就有两种观点，</p><p data-pid="AQkrqtFq">按照罗素和弗雷格的观点，既然命题是建立在结构之中，就需要一种结构上的要素来建立起关系。而这种关系在哪里呢？就需要在结构层次找，他们就是用来设定一个结构常项。</p><p data-pid="SWoyTDhq">比如说，p和非p，之间应当有一个结构上的关系，他决定了p和非p是不一样的，因此什么东西呢？就是逻辑常项。</p><p data-pid="Jab0YkXP">而维特根斯坦认为，结构不是最终决定结构关系的东西，真正决定结构关系的是真值运算，</p><blockquote data-pid="RoVbYLKT">5．232整编成一个系列所依赖的内在关系，<b>等价于一个从一项产生出另一项来的运算</b>。</blockquote><p data-pid="TLPkwuuR">真值运算就是构成一个由命题构成的形式序列的内在关系。那么按照上面所说，我们从基本命题出发，通过迭代运算的方式，构造出各种各样的命题，从而把命题确定下来。</p><p data-pid="XXiZj1aM">但是，在这里，同一个命题却可以通过不同的真值函项获得的。比如说p→q，与¬（p∧¬q），两者在真值上是等价的，也就是是同一个命题，但是却由于不同的真值函项获得的。</p><p data-pid="K5j-m3-a">因此我们可以看到，真值函项的区别仅仅是表面上的区别，也就说明了真值函项并不是真正的结构要素，也就是他并不是构成了命题关系，也就是并不需要一个逻辑常项或逻辑对象来说明。其次逻辑对象，仿佛是把逻辑符号实体化了。</p><blockquote data-pid="G14Dw424">5．43从一个事实 p会得出无数其它事实，即～～p，～～～～p等等，这看起来有点令人难以置信。同样使人惊讶的是，无数的逻辑（数学）命题是从半打“初始命题”得出来的。 但是一切逻辑命题之所说都是相同的，即什么也没有说。</blockquote><p data-pid="H7l0zaU1">因此在这里，他说，人们会认为p和非非p是不一样的命题，但是非非p是从p导出的。所有的数学命题，都可以被视为是通过某个初始命题迭代出来的。</p><p data-pid="ccAatIKi">换言之，我们才会出现交叉定义的现象，即我们可以通过别的命题联结词，来为其他联结词进行定义</p><p data-pid="TXbY8kle">这也就意味着</p><blockquote data-pid="gJUKmil2">5．44真值函项不是实质函项。</blockquote><p data-pid="X9f6OJy6">也就是说，命题的真值函项只不过是真值运算的结果，而不是用一个表达式来满足另一个表达式的结果。或者说，在一个命题加上真值函项，并不改变其命题的涵义。</p><p data-pid="EN1AYH7c">譬如说，p与非p，具有相同的涵义（的可能性）。为什么呢？因为我们是先把握命题的涵义，然后我们再去分析他的真值条件。p和非p，都在言说p这个事实，共享着意义可能性（即真假两极）。当然就其外在的事实一直与否，这不是在一个层次来谈论这个问题。在这个外在层次上说，我们可以说，他们的涵义是不同的。</p><p data-pid="uoZtXDqn">因此p和非p，并不改变涵义，指的是，并不改变我们理解命题。对于理解来说，首要的就是理解是可能的。因此正在这个意义上说，我们可以说，知道了一个命题，也就知道了以此为基础的一切运算结果。</p><blockquote data-pid="SWo8soa2">5．442如果给定一个命题，那么以它为基础的一切其值运算的给果也随之给定。</blockquote><p><br></p><blockquote data-pid="Y8FV-oDQ">5．45 如果有了逻辑的初始记号，那么任何正确的逻辑就必须能够清楚地表明这些记号彼此之间的相对地位，并证明它们存在的合理性。以其初始记号为基础的逻辑的构造，必须是清楚的。<br>5．451如果逻辑有一些初始概念，它们就应该是互相独立的。如果引入了一个初始概念，那么在它出现的一切结合里，它都是应该是已经引入了的。因此，它不能先对一种结合引入，尔后又对另一种结合再次导队。例如，一旦引入了否定，我们就应该既在“～p”形式的命题中理解它，也在“～（pVq）”、“（?x）·～fx”等等这样的命题中同样地理解它。我们不应先对一类情况引入它，然后又对另一类情况目队它，因为这样一来，它的指调在两类情况中是否相同，就值得怀疑，而且没有理由在两类情况下应用同一种记号结合方式。<br>（简言之，弗雷格（在《算术的基本定律》中）关于通过定义引人记号的意见，经过适当的修改，也适用于初始记号的引入。）<br>5．452在逻辑的符号系统中引入任何一种新的手段都必然是一个重大事件。在逻辑中，一种新的手段不能以所谓漫不经心的态度在括号或者脚注中引入。<br>（如在罗素和怀特海的《数学原理》中就出现了用文字表达的定义和初始命题。为什么这里忽然出现文字呢？这是需要说明理由的，但是没有提出理由，也必然提不出理由，因为这种程序事实上是非法的。）<br>但是，如果证明在某处引入一种新的手段是必要的，我们就应立即追问：这种手段在哪些地方是必须用到的？必须弄清楚它在逻辑中的地位。<br>5．453在逻辑中一切数都需要说明理由。<br>或者不如说，必须弄清楚，逻辑中是没有数的。<br>不存在特别的数。<br>5．454逻辑中没有并列，也不可能有分类。<br>逻辑中不可能有普遍和特殊的区分。<br>5．4541逻辑问题的解决必定是简单的，因为它们设立了简单性的标准。<br>人们一直猜想，必定有一个领域，其中对问题的回答对称地——先天地——结合着而构成一个自足的系统。“<br>这个领域遵从如下规则：简单性是真理的标志。<br>5．46 如果我们恰当地引入逻辑记号，那么我们也就同时引入了它们的一切结合——不仅“pVq”，也有“～（pV～q）”等等——的意义。同时我们也就引入了括号的一切可能结合的效用；因此很清楚，真正一般的初始记号不是“pVq”、“（?x）·fx”等等，而是它们的结合的最一般形式。<br>5．461 和真实的关系不同，像 V 和?这种逻辑的伪关系是需要用到括号的，这一点看起来不太重要，事实上却具有重大意义。<br>的确，对这些表面上的初始记号使用括号，本身即已表明它们不是真正的初始记号。<br>当然没有人会认为，括号具有独立的指谓。<br>5．4611逻辑运算的记号是标点符号。</blockquote><p data-pid="ZqJt_NGv">如果我们引入初始词项，那么按照上面所说，我们可以通过基本命题迭代出命题，那么初始词项的目的无非就是为了刻画运算结果之间的结构关系，因此初始词项得到的逻辑结构应当是清楚明白的。</p><p data-pid="jvV4MHje">而初始概念应该是最基本的概念，</p><p data-pid="yM9K3A7n">1、他们已经不能交叉定义了，所以他们之间必须是独立的</p><p data-pid="woXacoZe">2、并且基本概念在他一切出现的场合之中，必须是同一个概念。</p><p data-pid="aF3O0k0g">在第二点中，就是针对罗素的类型论，罗素的类型论，可以为不同的逻辑类型引入量词，而这些量词可以采用同一个逻辑记号。这一点维特根斯坦是不能容忍的，因为在他看来，逻辑词项就是用来刻画命题结构，那么不同的东西就应该用不同的记号来标明，相同的东西应该用系统的记号标明。</p><blockquote data-pid="lKyJkVXF">5．451如果逻辑有一些初始概念，它们就应该是互相独立的。如果引入了一个初始概念，那么在它出现的一切结合里，它都是应该是已经引入了的。因此，它不能先对一种结合引入，尔后又对另一种结合再次导队。例如，一旦引入了否定，<b>我们就应该既在“～p”形式的命题中理解它，也在“～（pVq）”、“（?x）·～fx”等等这样的命题中同样地理解它。我们不应先对一类情况引入它，然后又对另一类情况目队它，因为这样一来，它的指调在两类情况中是否相同，就值得怀疑</b>，而且没有理由在两类情况下应用同一种记号结合方式。<br>（简言之，弗雷格（在《算术的基本定律》中）关于通过定义引人记号的意见，经过适当的修改，也适用于初始记号的引入。）</blockquote><p data-pid="IPs6yFlo">我们也不能在同样的地方用不同的记号。同样，我们不能一边用逻辑符号刻画命题结构，然后用文字形式来定义符合和用文字给出基本命题。</p><p data-pid="CDyOz91M">为什么不能呢？因为文字并不能给出定义，而仅仅只不过是对于符号的说明或者说对于逻辑体系的阐明，他是置身于逻辑体系之外的东西。因为逻辑体系是一个严密的体系，他的一切都被规定好了，任何新引入的记号都有自己的位置和作用，不需要一个外在的文字来定义。</p><blockquote data-pid="EuRIIAxN">5．452在逻辑的符号系统中引入任何一种新的手段都必然是一个重大事件。在逻辑中，一种新的手段不能以所谓漫不经心的态度在括号或者脚注中引入。<br>（如在罗素和怀特海的《数学原理》中就出现了<b>用文字表达的定义和初始命题。</b>为什么这里忽然出现文字呢？这是需要说明理由的，但是没有提出理由，也必然提不出理由，因为这种程序事实上是非法的。）<br>但是，如果证明在某处引入一种新的手段是必要的，我们就应立即追问：这种手段在哪些地方是必须用到的？<b>必须弄清楚它在逻辑中的地位。</b></blockquote><p data-pid="6O1oc9Zt">也正是因为如此，所以逻辑没有给数留下位置。也没有给类别留下位置。为什么呢？</p><p data-pid="fAa1OLX6">逻辑中是否有数或者类，依赖于有没有逻辑理由必须标明的客体。而客体概念，是形式概念。他是不能被量词来表达，所以他没有数和类。</p><blockquote data-pid="VpbVn0BN">5．453在逻辑中一切数都需要说明理由。<br>或者不如说，必须弄清楚，逻辑中是没有数的。<br>不存在特别的数。<br>5．454逻辑中没有并列，也不可能有分类。<br>逻辑中不可能有普遍和特殊的区分。</blockquote><p data-pid="-OLCJ06N">既然逻辑体系之中，一切都是预先规定的，那么要做的只不过把规定的东西直接描述出来。所以，逻辑本身规定了什么，我们只需要对此进行充分的注意。换言之，这表明逻辑体系是一个自足的体系，它不仅给出了答案是什么，也给出了问题本身</p><blockquote data-pid="km1nT-Pb">5．4541逻辑问题的解决必定是简单的，因为它们设立了简单性的标准。<br>人们一直猜想，必定有一个领域，其中对问题的回答对称地——先天地——结合着而构成一个<b>自足的系统</b>。“<br>这个领域遵从如下规则：<b>简单性是真理的标志。</b></blockquote><p><br></p><blockquote data-pid="7i39vEN3">5．46 如果我们恰当地引入逻辑记号，那么我们也就同时引入了它们的一切结合——不仅<b>“pVq”，也有“～（pV～q）”等等</b>——的意义。同时我们也就引入了括号的一切可能结合的效用；因此很清楚，真正一般的初始记号不是“pVq”、“（?x）·fx”等等，而是它们的结合的最一般形式。</blockquote><p data-pid="kVr23wJ-">当我们引入了逻辑记号，也就引入了与之结合的涵义。原因在于，引入了逻辑记号，就是引入了他们相互结合的可能性。故而，引入逻辑记号，不过就是引入了分解命题的一种方式（换言之，我们先去理解命题的涵义，才去分析命题，而不是相反。所以我们可以说逻辑记号的引入，才引入了一切涵义。因为涵义是前提。）</p><blockquote data-pid="uz3hlVvr">5．4611逻辑运算的记号是标点符号。</blockquote><p data-pid="fn6PW_dO">因此，逻辑联结词，本身不表示任何真正的关系，因为既然我们引入记号仅仅用来帮助我们分解或分析命题，那么我们可以说，他本质上只不过标点符号，也就是本身并没有独立意义。因为其意义在分解之前就给出了</p><p></p><p></p>